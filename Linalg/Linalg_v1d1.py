
import matplotlib as mpl
# import pymultinest
import numpy
from numpy import *
import pylab as P
import time
import sys
import os
import numpy as np

import BayesEoR.Params.params as p

#####
#
#Useful DFT link:
#https://www.cs.cf.ac.uk/Dave/Multimedia/node228.html
#
#####



###
#2D DFT testing
###


def makeGaussian(size, fwhm = 3, center=None):
	""" Make a square gaussian kernel.
	size is the length of a side of the square
	fwhm is full-width-half-maximum, which
	can be thought of as an effective radius.
	"""
	x = np.arange(0, size, 1, float)
	y = x[:,np.newaxis]
	if center is None:
		x0 = y0 = size // 2
	else:
		x0 = center[0]
		y0 = center[1]
	return np.exp(-4*np.log(2) * ((x-x0)**2 + (y-y0)**2) / fwhm**2)




###
def make_Gaussian_beam(image_size_pix, fwhm_pix, beam_peak_amplitude, center_pix=[]):
	"""
	Make a square gaussian kernel centered on center_pix=[x0, y0].
	"""
	x = np.arange(0, image_size_pix, 1, float)
	y = x[:,np.newaxis]
	if not center_pix:
		x0 = y0 = image_size_pix // 2
	else:
		x0 = center_pix[0]
		y0 = center_pix[1]
	gaussian_beam = beam_peak_amplitude * np.exp(-4*np.log(2) * ((x-x0)**2 + (y-y0)**2) / fwhm_pix**2)

	# Temporary workaround for using healpix coordinates in Finv
	# Currently only implemented for nside=64 and a fwhm=2.0 deg
	if p.FWHM_deg_at_ref_freq_MHz == 2.0:
		if p.nside == 64:
			gaussian_beam = np.array([1.5429574754156346e-18, 1.9178449777386548e-15, 2.786972622750653e-13,
									  4.731836134518815e-12, 9.383055723401052e-12, 2.172890251557421e-12,
									  5.877503601794784e-14, 1.8578638584039205e-16, 6.867944693834916e-20,
									  4.055739629715522e-18, 1.4063499053633091e-14, 5.774323265840633e-12,
									  2.8050787367442667e-10, 1.6113907764383902e-09, 1.0943785676704389e-09,
									  8.787544055596714e-11, 8.345384673960555e-13, 9.379362335679446e-16,
									  3.544273028955931e-14, 4.05736846174813e-11, 5.5667179091238424e-09,
									  9.147468065786963e-08, 1.799634805184335e-07, 4.238476278406098e-08,
									  1.1952597454017902e-09, 4.037872009770764e-12, 1.6353722649443194e-15,
									  3.075566131321859e-14, 9.682386606915661e-11, 3.7019040547343434e-08,
									  1.7174915314166612e-06, 9.66405838293434e-06, 6.593499078034229e-06,
									  5.454900569618523e-07, 5.474220812685031e-09, 6.668063623129015e-12,
									  7.857311650312034e-11, 8.256364546619909e-08, 1.0669866533538997e-05,
									  0.00016946699534557043, 0.0003306718547827697, 7.926002387958822e-05,
									  2.334231090213377e-06, 8.450511954080801e-09, 3.763724619783035e-12,
									  2.170751912164745e-11, 6.17990305347842e-08, 2.1937637677115413e-05,
									  0.0009702096457412907, 0.0053428238397393805, 0.0036626766326666887,
									  0.0003125881075805589, 3.322362213089829e-06, 4.4005570985023145e-09,
									  1.553144467876257e-08, 1.4927703872868087e-05, 0.0018126274087790228,
									  0.027787571697491697, 0.05375813739049106, 0.01312342258129921,
									  0.0004043427384002353, 1.5731672783686657e-06, 7.735332420827387e-10,
									  1.3109777899556915e-09, 3.3610459238401164e-06, 0.0011043700024413992,
									  0.04646609281624278, 0.2502040735072594, 0.17237693184781486,
									  0.015195494350207344, 0.0001714590118704875, 2.478044947028477e-07,
									  2.502819661300893e-07, 0.00021921288662126131, 0.024946029880392188,
									  0.36856935127807616, 0.7067073282845534, 0.1758405820098311,
									  0.0056787223473646585, 2.3815705736420934e-05, 1.2981460939032915e-08,
									  6.159296469604722e-09, 1.4158410454649456e-05, 0.004292215988098864,
									  0.17145190516430409, 0.901872876569851, 0.6245647585097986,
									  0.05694607499414412, 0.0006838604791008783, 1.082406033692004e-06,
									  2.9707539374876466e-07, 0.00023618835262924844, 0.025120353717397143,
									  0.3571442108682603, 0.6784649626676934, 0.17219976708725668,
									  0.005840558425514967, 2.648672736343014e-05, 1.6074228665171336e-08,
									  2.0210139526926994e-09, 4.146148837207794e-06, 0.0011557224361505533,
									  0.04373156676507598, 0.2244974147672067, 0.15630985748037157,
									  0.014762020240173415, 0.0001891721247916709, 3.291773354024384e-07,
									  2.315082528246073e-08, 1.6638463561231937e-05, 0.0016491283063018592,
									  0.022524590415417177, 0.0423770953077629, 0.01098073784716951,
									  0.00039197261651112463, 1.9286139440613246e-06, 1.309138872484151e-09,
									  4.097717125865548e-11, 7.465781037138836e-08, 1.9065569485059707e-05,
									  0.0006817972404132826, 0.0034121419079391493, 0.0023891657966409446,
									  0.00023406646187771593, 3.209796720468168e-06, 6.165646717833122e-09,
									  1.0393697967187723e-10, 6.72292730363983e-08, 6.190655340553006e-06,
									  8.108924160885698e-05, 0.0001510233738810168, 3.998826045176625e-05,
									  1.5056654999958881e-06, 8.066397171221128e-09, 6.154330429033313e-12,
									  4.466450339071686e-14, 7.189201961196115e-11, 1.675495470518603e-08,
									  5.648459043037198e-07, 2.752770034866073e-06, 1.9388365261175204e-06,
									  1.9736527447334338e-07, 2.904921993893883e-09, 6.186676251470419e-12,
									  2.316382261631485e-14, 1.3421429330198291e-11, 1.1444255260200882e-09,
									  1.4349176592254448e-08, 2.6443469043914074e-08, 7.161662798859743e-09,
									  2.851122650426398e-10, 1.6694670178356054e-12, 1.4391432160174018e-15,
									  2.2325472807818782e-18, 3.1569956925985092e-15, 6.686992985823238e-13,
									  2.119538769209421e-11, 1.0046812544419545e-10, 7.119786101992638e-11,
									  7.543708637256962e-12, 1.1955345502219266e-13, 2.8361625704375544e-16,
									  2.1614659690538748e-19, 1.116221000969394e-16, 8.782563959275416e-15,
									  1.0519724890535021e-13, 1.91732716464422e-13, 5.3167685790557e-14,
									  2.2436953515783898e-15, 1.4417954180725986e-17])
		elif p.nside == 128:
			gaussian_beam = np.array([1.0990974208603662e-21, 8.770838406741156e-20, 4.087448014673502e-18,
									 1.0704377105170448e-17, 2.6634125448057545e-19, 3.869956716070694e-21,
									 1.8031447013404774e-21, 1.8583896947806958e-19, 1.1203068730341723e-17,
									 3.9497815970632947e-16, 8.143189663774312e-15, 9.81654259029647e-14,
									 6.918785519114041e-13, 2.850892669385299e-12, 6.867387171091985e-12,
									 9.670511308104123e-12, 7.960672217722955e-12, 3.830850446835851e-12,
									 1.0776956822875673e-12, 1.7724357782861103e-13, 1.7042912804297375e-14,
									 9.581846724948486e-16, 3.1501225648695873e-17, 6.056572215309507e-19,
									 6.810885680653303e-21, 3.025901669127919e-19, 2.3556910138998967e-17,
									 1.0742618610635262e-15, 2.8692975175392724e-14, 4.4881521999280163e-13,
									 4.1109935824845015e-12, 2.2048628727115896e-11, 6.923854445653554e-11,
									 1.2730031697623777e-10, 1.370305977489758e-10, 8.635969083592652e-11,
									 3.186520081636224e-11, 6.884121680099929e-12, 8.708204322098388e-13,
									 6.450396834085666e-14, 2.798074247264601e-15, 7.108728388102375e-17,
									 1.0578816834907931e-18, 3.7873300735516014e-19, 3.80121478244562e-17,
									 2.2384193376043212e-15, 7.732701493027132e-14, 1.5668973160262336e-12,
									 1.862197813499541e-11, 1.2979300860825328e-10, 5.305043520549707e-10,
									 1.2715060678956374e-09, 1.7870106399717695e-09, 1.472685945556591e-09,
									 7.116562060962759e-10, 2.0165915041250457e-10, 3.3509768398034106e-11,
									 3.265552293952162e-12, 1.8664107581914866e-13, 6.256977094006737e-15,
									 1.2304891204203185e-16, 1.4197234596318749e-18, 4.7083952377085705e-17,
									 3.574199223867418e-15, 1.5942689895190833e-13, 4.177975388016745e-12,
									 6.431967602615099e-11, 5.816417472266724e-10, 3.089362656808088e-09,
									 9.637390215738927e-09, 1.7656744184234548e-08, 1.8998250232056468e-08,
									 1.2005142289805857e-08, 4.455315310130954e-09, 9.710944344207552e-10,
									 1.243193135205677e-10, 9.348455591025183e-12, 4.129553142611305e-13,
									 1.0717013280450726e-14, 1.634200754940791e-16, 4.4780690564799346e-17,
									 4.37452576717418e-15, 2.5151483717416043e-13, 8.509984207299259e-12,
									 1.6942378222481975e-10, 1.9845237224223423e-09, 1.3675342244777017e-08,
									 5.5435967012816807e-08, 1.3218918565622943e-07, 1.854121933573478e-07,
									 1.5297262999223547e-07, 7.423779903955037e-08, 2.119254002954558e-08,
									 3.558819740583215e-09, 3.515769063343525e-10, 2.0434321269684297e-11,
									 6.988237067510242e-13, 1.4063468673313663e-14, 1.66568330211745e-16,
									 4.104912772298008e-15, 3.036903293549139e-13, 1.3243746010194802e-11,
									 3.403981392637582e-10, 5.155983309636756e-09, 4.601964637562831e-08,
									 2.42019224592416e-07, 7.499054824683432e-07, 1.368977841432306e-06,
									 1.47234833539396e-06, 9.329275056975623e-07, 3.482693048032807e-07,
									 7.659971485455397e-08, 9.926732667091815e-09, 7.580243907364651e-10,
									 3.4111127894026335e-11, 9.046723289386209e-13, 1.414239860385227e-14,
									 2.953929692788516e-15, 2.8070739709375477e-13, 1.57503472865052e-11,
									 5.217328320344906e-10, 1.0201760892930323e-08, 1.1774059431476381e-07,
									 8.019818851164284e-07, 3.223749200768753e-06, 7.647074884242551e-06,
									 1.070419083502846e-05, 8.841616748287715e-06, 4.309548260744212e-06,
									 1.23955227870649e-06, 2.1040194232657965e-07, 2.1077211222235318e-08,
									 1.2462056735360039e-09, 4.349327480404881e-11, 8.961091645902115e-13,
									 1.0900960567162081e-14, 1.986638274796917e-13, 1.431662710221578e-11,
									 6.101254452441957e-10, 1.537435269213978e-08, 2.29047017017348e-07,
									 2.017257767718557e-06, 1.0502047790349574e-05, 3.231746721470158e-05,
									 5.878063558744886e-05, 6.319107952132854e-05, 4.015140134563554e-05,
									 1.507911915868524e-05, 3.3473141120057747e-06, 4.392230206950708e-07,
									 3.4070049398938045e-08, 1.5624222259797245e-09, 4.236517415147922e-11,
									 6.792967560209491e-13, 1.0767338678784684e-13, 9.94792574275145e-12,
									 5.444494205443901e-10, 1.7649064048041666e-08, 3.388218128754979e-07,
									 3.851776684846069e-06, 2.592707322931668e-05, 0.00010332828526715155,
									 0.00024380186835783999, 0.00034056006687549695, 0.0002816334044791272,
									 0.0001378831755156585, 3.9965572047761056e-05, 6.858473598907376e-06,
									 6.96887526388552e-07, 4.19301937545084e-08, 1.4940435824183742e-09,
									 3.152994709350864e-11, 3.9415430115648266e-13, 5.2848319325688085e-12,
									 3.7077994413830295e-10, 1.5434406360673893e-08, 3.811484898303739e-07,
									 5.583148240136754e-06, 4.850684815598438e-05, 0.0002499380023120087,
									 0.0007637327304002085, 0.0013839265297974769, 0.0014870924167004113,
									 0.0009475781966577212, 0.000358056311261175, 8.02346374449471e-05,
									 1.0662768433829857e-05, 8.404404466012644e-07, 3.929273834431636e-08,
									 1.0897670724248699e-09, 1.793192504688569e-11, 2.146829755713862e-12,
									 1.9272729741060142e-10, 1.0283401467396708e-08, 3.260736357767836e-07,
									 6.143637073464311e-06, 6.877336058267787e-05, 0.00045736384360016793,
									 0.0018068435684101213, 0.004240087907201399, 0.00591032502542398,
									 0.004893559303020329, 0.0024066797043897055, 0.0007030768827922248,
									 0.00012201064845876847, 1.2578548790456952e-05, 7.704366108000641e-07,
									 2.8038885076750665e-08, 6.063929232133797e-10, 7.794304969279338e-12,
									 7.646829638723266e-11, 5.220259662593403e-09, 2.121547453558523e-07,
									 5.132210419917761e-06, 7.389186176674211e-05, 0.0006331212305504551,
									 0.0032280568647099247, 0.009793404055248508, 0.01767855525217987,
									 0.01898764509429293, 0.01213404347646825, 0.0046137832859558855,
									 0.0010438578697415173, 0.00014053407797938482, 1.125925977520762e-05,
									 5.368661310897919e-07, 1.5236965428214077e-08, 2.574327983518112e-10,
									 2.316158395423663e-11, 2.019203402485527e-09, 1.0498238962491272e-07,
									 3.2547221847751405e-06, 6.016131854351874e-05, 0.0006629486969452687,
									 0.004354749449069823, 0.017050492697794236, 0.03979049431867566,
									 0.055344797565048884, 0.045880068249952624, 0.022668568416871322,
									 0.00667556781507404, 0.001171752784034154, 0.00012260136986951776,
									 7.647198928012903e-06, 2.843817328740345e-07, 6.3058855890817555e-09,
									 8.338669198903439e-11, 5.951396914787096e-10, 3.951042066386681e-08,
									 1.5669155247357758e-06, 3.711598448070833e-05, 0.0005250571020456545,
									 0.004435466550600414, 0.02237302652908072, 0.06738087194962662,
									 0.12115940509164767, 0.13006988601956881, 0.08336703596033516,
									 0.03190194289540467, 0.007288877020982979, 0.0009943716359929904,
									 8.100535070040443e-05, 3.9409070109815245e-06, 1.1451046563205999e-07,
									 1.9875501395984464e-09, 1.3366588843937417e-10, 1.1309324575294009e-08,
									 5.726434145032888e-07, 1.734998192558688e-05, 0.000314503175897823,
									 0.0034104748131147935, 0.022122257696550292, 0.08582982926816729,
									 0.19916777845109773, 0.2764128161848208, 0.229429986837909,
									 0.11389328992813086, 0.03381531984019169, 0.0060050430046610925,
									 0.0006378730839999866, 4.0532618222924796e-05, 1.5408926829290703e-06,
									 3.505024478557445e-08, 4.771145740777571e-10, 2.4619709671839566e-09,
									 1.5885748421841527e-07, 6.144627798582249e-06, 0.00014245775148527954,
									 0.0019793708263470783, 0.016480686353401847, 0.08222340083066561,
									 0.24578819988127557, 0.44020399951794026, 0.47235082205013096,
									 0.3036630425498406, 0.1169615384123669, 0.02699192351273832,
									 0.0037324023610019086, 0.00030927131335147824, 1.5357784636183794e-05,
									 4.5709339488794967e-07, 8.155056143767462e-09, 4.0760039396654393e-10,
									 3.3449219114906045e-08, 1.6485684125684914e-06, 4.879016859306698e-05,
									 0.0008669725589037327, 0.009248642096859338, 0.05922575933592344,
									 0.22765245440967943, 0.5252192026104088, 0.7272796959558987,
									 0.6044348648126086, 0.30150034628743094, 0.09026678903544366,
									 0.016221468705250736, 0.0017498588194794725, 0.00011331925302282752,
									 4.40593407382548e-06, 1.0286323810485182e-07, 1.4422255318482698e-09,
									 5.345414948212991e-09, 3.3502818093605083e-07, 1.263275030926511e-05,
									 0.00028652978792516293, 0.003908806801123399, 0.03206838412167954,
									 0.15820961756951912, 0.469336895469146, 0.8371710238268828,
									 0.8978661526716692, 0.5789962516116094, 0.22449880856545926,
									 0.05234105105799579, 0.007338131771336149, 0.0006186946891432943,
									 3.1373056575880814e-05, 9.569234555374976e-07, 1.7558866503153362e-08,
									 6.482580162040945e-10, 5.1565375592104706e-08, 2.4723397165337075e-06,
									 7.143838903350124e-05, 0.0012438593646784959, 0.013049031633121981,
									 0.08247315058051294, 0.3140094812950512, 0.720188254333483,
									 0.9949660552176726, 0.8279878195343838, 0.4150459816946803,
									 0.12532474333088064, 0.022796395282396655, 0.0024981201490849986,
									 0.0001649361867083526, 6.5617611724372695e-06, 1.573192137816667e-07,
									 2.2733364845672223e-09, 6.009909620079239e-09, 3.6566124840479374e-07,
									 1.3433604024053417e-05, 0.0002979521860644484, 0.003989216481959331,
									 0.03223821040279528, 0.15723910123347787, 0.46283821321332336,
									 0.8221637273889842, 0.8813288340877738, 0.5701209660056213,
									 0.22256296943767667, 0.05243386241302269, 0.007455361828055149,
									 0.0006398189848686177, 3.314510072344583e-05, 1.0365885739371097e-06,
									 1.9573933865301902e-08, 5.30312021362643e-10, 4.086169291027645e-08,
									 1.9047758650669624e-06, 5.3708997976834934e-05, 0.0009159413907133092,
									 0.009446183922340451, 0.05890776976369503, 0.22211832904226528,
									 0.5063709351261212, 0.6979292051920458, 0.5815762019336841,
									 0.2929933104101615, 0.08924348537580444, 0.01643553143852924,
									 0.001830243258980183, 0.00012325084604716417, 5.019656517106935e-06,
									 1.2365647157077722e-07, 1.8428204605692711e-09, 3.449181887722375e-09,
									 2.035946813747519e-07, 7.283476120255517e-06, 0.00015789556191492533,
									 0.0020739866925728084, 0.016504468435038798, 0.07956465716612952,
									 0.23234551512158627, 0.41098409335216685, 0.4403341201634308,
									 0.28576238335256665, 0.11233129540396829, 0.02674766410886048,
									 0.003858207218830442, 0.00033715830338269955, 1.7851456139601475e-05,
									 5.727388022086598e-07, 1.1136360712359035e-08, 2.1986846389167044e-10,
									 1.639946695802409e-08, 7.428070252080872e-07, 2.0428378447955433e-05,
									 0.0003410707497715885, 0.003456668410459248, 0.021263389674937263,
									 0.07938465448838795, 0.17986494378496862, 0.24731353753844665,
									 0.20636450480509835, 0.10449874327768446, 0.03211353874759729,
									 0.005989453935224489, 0.000678013070555842, 4.658856808215479e-05,
									 1.9433843197561267e-06, 4.921897238251558e-08, 7.569484541101642e-10,
									 9.951568176471654e-10, 5.695099376247809e-08, 1.982835763070096e-06,
									 4.199368995127659e-05, 0.0005409266346663301, 0.0042374429484704455,
									 0.020185690461730126, 0.05846953140495739, 0.10297761109945962,
									 0.11027398373522593, 0.07179912317510553, 0.028424231524250842,
									 0.006842242254708328, 0.0010015527240915297, 8.915573901382417e-05,
									 4.82690012877598e-06, 1.5895829637517903e-07, 3.184602914767268e-09,
									 4.547755411740897e-11, 3.2812869304021877e-09, 1.4432532270068653e-07,
									 3.869219503391657e-06, 6.321600151067738e-05, 0.0006293653692913119,
									 0.003817764845950003, 0.014109556465980232, 0.031768135841111586,
									 0.043574216559884346, 0.03641004454986173, 0.018534029559420274,
									 0.005747615873761102, 0.0010859155816750352, 0.0001250043205424655,
									 8.768267462773622e-06, 3.7480945558445325e-07, 9.765004963419186e-09,
									 1.5508357578417795e-10, 1.4201063831060358e-10, 7.874112036885257e-09,
									 2.666533875085572e-07, 5.514331002927874e-06, 6.962789394213556e-05,
									 0.0005367498695846478, 0.0025259311695638013, 0.007256105907239176,
									 0.01272327597976984, 0.013617495647031855, 0.008896050989594574,
									 0.003547372450645383, 0.0008634608244007165, 0.00012830118382995347,
									 1.1638734465373734e-05, 6.446320214010422e-07, 2.1802285410307892e-08,
									 4.5033768398543816e-10, 4.6145925221879566e-12, 3.218472042106596e-10,
									 1.3738049394194695e-08, 3.588308616714782e-07, 5.734340343655842e-06,
									 5.606022281166087e-05, 0.000335244514893059, 0.0012262273153950858,
									 0.0027432081899053514, 0.003753272969150267, 0.003140648561207288,
									 0.001607272937104048, 0.0005030757692766031, 9.631016123263429e-05,
									 1.1278109879411528e-05, 8.079150475617881e-07, 3.540862096849048e-08,
									 9.495638521189856e-10, 1.5583974443849707e-11, 9.850484572233733e-12,
									 5.288244343926075e-10, 1.7408283770648224e-08, 3.513383365760176e-07,
									 4.346744097487347e-06, 3.296283402563641e-05, 0.0001532036487870635,
									 0.00043638426309181044, 0.0007617367689839353, 0.0008148285326305076,
									 0.0005341358764794526, 0.00021457017971293513, 5.282458556025201e-05,
									 7.970363337804782e-06, 7.371073673556692e-07, 4.178673918363218e-08,
									 1.4522954406322991e-09, 3.094874769455645e-11, 2.2562110253650702e-13,
									 1.5200023634481186e-11, 6.292346712223226e-10, 1.6003480673858403e-08,
									 2.500279310262131e-07, 2.3992912349424154e-06, 1.4140184935062634e-05,
									 5.117659985264273e-05, 0.00011373855996205695, 0.00015522044454686934,
									 0.00013007359952672408, 6.693168595756106e-05, 2.114897229871263e-05,
									 4.103773622792591e-06, 4.890407822515179e-07, 3.5794348139186884e-08,
									 1.6093144293338472e-09, 4.445115262585913e-11, 7.544121667259308e-13,
									 3.2601973588697025e-13, 1.693415433798469e-11, 5.415482424573178e-10,
									 1.066101690939385e-08, 1.291787545703077e-07, 9.63311973542874e-07,
									 4.420668301047043e-06, 1.248317254848103e-05, 2.168993828347873e-05,
									 2.3188755176258396e-05, 1.525390573898671e-05, 6.174149794335382e-06,
									 1.5377402222918534e-06, 2.3568122112117837e-07, 2.2229972535660948e-08,
									 1.2905351413862654e-09, 4.61181644045824e-11, 1.014633200267794e-12,
									 5.214501288602773e-15, 3.39073350274048e-13, 1.3603844225669091e-11,
									 3.367018570144573e-10, 5.140239613908274e-09, 4.839747258562251e-08,
									 2.8100903154626693e-07, 1.0061026402662579e-06, 2.221079825569567e-06,
									 3.0232264399397284e-06, 2.5372069128496843e-06, 1.3128743571098943e-06,
									 4.1887572530415964e-07, 8.240697102231816e-08, 9.997484505946475e-09,
									 7.480078902707257e-10, 3.4519160400588986e-11, 9.826801353894072e-13,
									 1.7259599118602984e-14, 5.047410290038088e-15, 2.53475507452543e-13,
									 7.869732056007792e-12, 1.5103357314779896e-10, 1.7915095275821094e-09,
									 1.3132538651344281e-08, 5.948718870423625e-08, 1.6649991681283121e-07,
									 2.879389441210361e-07, 3.076606547948312e-07, 2.031081685847937e-07,
									 8.284661504929383e-08, 2.088004961281507e-08, 3.251804729985773e-09,
									 3.1296064853336387e-10, 1.861542261127091e-11, 6.844297899216937e-13,
									 1.5556865566882434e-14, 5.581273345393594e-17, 3.5001546980802528e-15,
									 1.3600387902799632e-13, 3.2738093798493074e-12, 4.881248582623882e-11,
									 4.507448462195218e-10, 2.5775626681131692e-09, 9.127084244241818e-09,
									 2.0011259155178086e-08, 2.716569938051899e-08, 2.2833131646645617e-08,
									 1.1882603283967518e-08, 3.828882735579313e-09, 7.63957368066176e-10,
									 9.439183611287321e-11, 7.222858202609343e-12, 3.4232894602663527e-13,
									 1.005073971208876e-14, 1.8282760073317035e-16, 3.5786584986012525e-17,
									 1.7362264004937805e-15, 5.229882824082143e-14, 9.779335657826966e-13,
									 1.1350117220846691e-11, 8.175536375713468e-11, 3.6544151690132717e-10,
									 1.0136208263573849e-09, 1.7444918276801485e-09, 1.8628906335772564e-09,
									 1.234324878334173e-09, 5.074619365466268e-10, 1.294574236681661e-10,
									 2.0494014910257682e-11, 2.0134475423754214e-12, 1.2277582075785123e-13,
									 4.6472945873534464e-15, 1.0921127579253062e-16, 2.7065534144509247e-19,
									 1.63564159279704e-17, 6.150832755154758e-16, 1.4390670665549654e-14,
									 2.0944316421132364e-13, 1.8959882880139466e-12, 1.0674443167211072e-11,
									 3.737319985806007e-11, 8.136838554272353e-11, 1.1015796075020387e-10,
									 9.27331004059106e-11, 4.8541794349346745e-11, 1.5800542356275035e-11,
									 3.1983484518935407e-12, 4.0263284074658787e-13, 3.1525632349595357e-14,
									 1.535467816057291e-15, 4.6526523009247424e-17, 8.772304436727229e-19,
									 1.1358856578943624e-19, 5.3198387117622086e-18, 1.5536265833399042e-16,
									 2.828854962169559e-15, 3.210936646600686e-14, 2.271750224809176e-13,
									 1.001745911263663e-12, 2.752914286901461e-12, 4.71460649198032e-12,
									 5.031586815669382e-12, 3.3463389969613143e-12, 1.3869110129240482e-12,
									 3.582273870389903e-13, 5.766707276459048e-14, 5.786193505647973e-15,
									 3.619099415820223e-16, 1.41125918511248e-17, 3.431449222319066e-19,
									 1.2290781325896184e-18, 2.7931122235588116e-17, 3.965889158649033e-16,
									 3.5178856791540737e-15, 1.949248294106527e-14, 6.746241241022788e-14,
									 1.4582784042128222e-13, 1.9687344134248163e-13, 1.6599530194097344e-13,
									 8.741177186437777e-14, 2.87489922720975e-14, 5.905771569211873e-15,
									 7.578170187179573e-16, 6.074741078480098e-17, 3.042415806831186e-18,
									 9.521340209858064e-20])
	elif p.FWHM_deg_at_ref_freq_MHz == 4.0:
		if p.nside == 64:
			gaussian_beam = np.array([3.5244267531776826e-05, 0.00020926826558669045, 0.0007265795590388124,
									  0.0014748825051204462, 0.0017501935293359925, 0.0012141139465171539,
									  0.0004923775306932189, 0.00011674908124732682, 1.6188503269239005e-05,
									  4.4876348975135446e-05, 0.0003443684430395464, 0.0015501555279872127,
									  0.0040924771574238, 0.006335781892237229, 0.005751642641307255,
									  0.003061729924079518, 0.0009557880360276045, 0.00017500212747457764,
									  0.0004338921495478002, 0.002523835892087056, 0.008637733558028809,
									  0.017391026846275817, 0.020596626614738517, 0.01434836576980099,
									  0.005879840879464401, 0.0014175491868517497, 0.0002010963356518354,
									  0.0004187755015462975, 0.003136863384555264, 0.013870952663640568,
									  0.036201257039473966, 0.05575577877385039, 0.05067327662384007,
									  0.02717669933764595, 0.008601626444310458, 0.0016069410078647574,
									  0.0029772718747128482, 0.01695107381562635, 0.05715309409423739,
									  0.11409622679328814, 0.1348494898628163, 0.09435470251528844,
									  0.03908732612126311, 0.009587839494649883, 0.0013928503574450884,
									  0.0021585024605706095, 0.015766867412551074, 0.06843802449002515,
									  0.17648849390965723, 0.2703601718246277, 0.2460082346032299,
									  0.13296676807661575, 0.04269349853310345, 0.008144734186095785,
									  0.011163566493977565, 0.06215817470785463, 0.20633701129158705,
									  0.40828427086577995, 0.4815163665659638, 0.33846345112495635,
									  0.14180365076790574, 0.035415528423113074, 0.005273752514859131,
									  0.006017260778470748, 0.042817234321012566, 0.1822966342741397,
									  0.46428434368524907, 0.7072510387961632, 0.6443469640391132,
									  0.3510982852168883, 0.1144300477415653, 0.02231142427494724,
									  0.022366982064417958, 0.12167924889712549, 0.3974205861493752,
									  0.7791656614925874, 0.9168745091798264, 0.6475596477251974,
									  0.2745128374116905, 0.06985795432615793, 0.010674090797063725,
									  0.008858960743213197, 0.061341391654103836, 0.2559589924652936,
									  0.6434807788967521, 0.9745100705885372, 0.888984868382712,
									  0.4885015532279057, 0.16171186155552866, 0.03225503749848119,
									  0.02334622519458371, 0.12396943425288222, 0.3981130717812038,
									  0.7730559082460048, 0.9075736037150759, 0.6441813392102423,
									  0.2764480896601616, 0.07173929018751202, 0.01125984819821932,
									  0.00670490035488763, 0.04512437732115172, 0.18437981975703463,
									  0.45729742852074395, 0.6883397282620543, 0.6287769196307297,
									  0.34856714486972423, 0.11727738818021326, 0.023952865803826422,
									  0.012335070026931334, 0.06386726298547754, 0.20151789200458098,
									  0.3874041115782705, 0.45371464357800645, 0.32371131563600614,
									  0.1407064260210662, 0.03726587523325243, 0.006015149554445005,
									  0.002530087224586432, 0.01652984617544917, 0.06607884533949106,
									  0.16158975027179498, 0.24168893678080203, 0.2210861679438388,
									  0.12369005926500308, 0.04232718459847558, 0.008861243262931964,
									  0.0031929529801056756, 0.01610236266463971, 0.049880885710290625,
									  0.0948944492703872, 0.11085646918593796, 0.0795212371599724,
									  0.03502935372240655, 0.009476978611477732, 0.001575053109786594,
									  0.00045971706716849733, 0.0029118578573557614, 0.01137721105263554,
									  0.027414636765717204, 0.04073263288691433, 0.037315159148734636,
									  0.021077431459906475, 0.007341479977704763, 0.0015771185775238126,
									  0.0003901239004523462, 0.001914034194496972, 0.005816301138695504,
									  0.010944772661881996, 0.012752038261004172, 0.009199272150668257,
									  0.0041091687349583865, 0.0011366963380274985, 0.0001947717667478954,
									  3.8654509459764326e-05, 0.00023703828555887607, 0.0009042899763631765,
									  0.0021456572143310764, 0.0031659720376939382, 0.002904803348974711,
									  0.0016572812867902337, 0.000588017881214596, 0.00012977253261059482,
									  2.1561903625459875e-05, 0.00010278684772957087, 0.00030612960442786657,
									  0.0005695096608335326, 0.0006617196880648153, 0.00048018870386548477,
									  0.0002176411299675518, 6.162059823059745e-05])
		elif p.nside == 128:
			gaussian_beam = np.array([5.757832770991652e-06, 1.7209183974056913e-05, 4.49638055039835e-05,
									 5.7199252079000095e-05, 2.2717451536624818e-05, 7.88726671094662e-06,
									 6.516398649504403e-06, 2.0762717604912903e-05, 5.7854114408768116e-05,
									 0.00014097537889482442, 0.00030039910715500586, 0.0005597442472011783,
									 0.0009120265199424876, 0.001299407044296895, 0.0016188174723585568,
									 0.001763446787631327, 0.0016797220972665458, 0.001399019601733444,
									 0.001018882342159072, 0.0006488474871208472, 0.0003613149699034486,
									 0.00017593907521091184, 7.491725614678509e-05, 2.7896950059682626e-05,
									 9.084497248173226e-06, 2.3453826208390532e-05, 6.966739653960653e-05,
									 0.00018104124992746515, 0.00041157017515588507, 0.000818496626963345,
									 0.0014239236382304619, 0.002166932564277842, 0.0028846091872522742,
									 0.0033589796386717203, 0.003421404230546922, 0.0030484408293660597,
									 0.0023759055112356673, 0.001619802759593445, 0.0009660111798010793,
									 0.0005039606279534877, 0.00022999310084978241, 9.182226052433664e-05,
									 3.207076167136587e-05, 2.480751651253072e-05, 7.852005630989104e-05,
									 0.00021751307207500573, 0.0005273304032772017, 0.001118819775754776,
									 0.0020773345920498064, 0.0033753034621861987, 0.004799237448637911,
									 0.005971447374267502, 0.006501772729345098, 0.006194803507078193,
									 0.005164967109263893, 0.0037683782047838368, 0.0024059846738811322,
									 0.0013442782152546357, 0.0006572821032308, 0.0002812490999327208,
									 0.00010532208416274613, 3.4518422463527727e-05, 8.283582995921411e-05,
									 0.0002445089096823458, 0.0006318884245218118, 0.0014296886496754256,
									 0.002831952482713339, 0.0049109316827907114, 0.007455336033903596,
									 0.009908088131891538, 0.011527301601149354, 0.011740278544367417,
									 0.010467472484866628, 0.008169954000164995, 0.005582328200430028,
									 0.003339140174899823, 0.0017485778284032547, 0.0008016333281780088,
									 0.0003217499160205554, 0.00011306452217657287, 8.180365277586143e-05,
									 0.00025717736645409004, 0.0007081755074616518, 0.001707977670324663,
									 0.0036078094615904343, 0.006674428325516729, 0.01081395482509092,
									 0.015344329184402223, 0.019067729478389212, 0.020750787016170124,
									 0.019776682137082113, 0.01650654848608249, 0.01206551191984321,
									 0.0077237195796079385, 0.004330171378245961, 0.0021261311690389047,
									 0.0009143067107337266, 0.000344368257061083, 0.00011360517316958006,
									 0.00025311972107281013, 0.0007423483381531743, 0.0019076676313451036,
									 0.00429533256250172, 0.008473793487239409, 0.014646566213803532,
									 0.022180047214390246, 0.029427382356280347, 0.03420574900651161,
									 0.0348339434464389, 0.031078637751464962, 0.024292868525664545,
									 0.016636301720192922, 0.009981632624637108, 0.005247117565676441,
									 0.0024167071108064063, 0.000975265422253878, 0.00034485042727295324,
									 0.00023313100645552755, 0.0007278861641685144, 0.0019921522834217944,
									 0.004779275233462665, 0.010050063021018626, 0.018523862810760523,
									 0.02992548100096505, 0.04237310720881838, 0.0525864478522097,
									 0.057199003241953615, 0.054529676531962966, 0.04556254107027219,
									 0.03336692706289959, 0.02141718737086846, 0.012049063327236207,
									 0.005941518189598705, 0.002568062133913464, 0.0009729493443203353,
									 0.00032312174991811106, 0.0006676205551999108, 0.0019451817142549562,
									 0.004969981640272263, 0.011135230462441213, 0.021876667195416907,
									 0.037686894257460274, 0.05692702622401892, 0.07539791376004229,
									 0.08756056785615801, 0.08915874437457626, 0.07960221946007472,
									 0.06231520000805536, 0.04277343388084513, 0.02574371824546732,
									 0.013586049444646616, 0.006287088910431846, 0.002551245484172746,
									 0.0009078516456594173, 0.0005728317659277506, 0.0017759598109479816,
									 0.004830469952686055, 0.011526047891948998, 0.024126417587665764,
									 0.04430117804342762, 0.07135729418835321, 0.10082188330269376,
									 0.12495661656956442, 0.1358464928181825, 0.12954511511918765,
									 0.10836220139612916, 0.07950995513659014, 0.05117488410546865,
									 0.028892869285246377, 0.014309739155349941, 0.006217142426496765,
									 0.002369631478838548, 0.0007923490973799248, 0.001516204548386151,
									 0.004388125690018425, 0.011146088385370448, 0.02484697659186041,
									 0.048609347315092366, 0.08345469303869933, 0.12573554644666227,
									 0.16623993130979065, 0.19287603017672286, 0.19637422755824627,
									 0.17545015846882095, 0.13755862728752524, 0.09464343050807117,
									 0.05714358648694346, 0.030277968736724004, 0.014079203104798743,
									 0.005745573971636836, 0.0020578168959416955, 0.0012104570982607449,
									 0.003725939578019542, 0.010070109611036963, 0.023896204238809296,
									 0.04978590294168902, 0.09106574851381924, 0.14623975716666499,
									 0.2061722158394784, 0.25517828550438426, 0.2772699736550029,
									 0.2644881469821903, 0.2214902298817148, 0.16283610463346745,
									 0.10509920570465253, 0.059553547214909026, 0.029626764682884034,
									 0.01294017605695709, 0.004962363012133116, 0.0016708764911052148,
									 0.002957129567594883, 0.008500080260452224, 0.021461653929586665,
									 0.047596620049604695, 0.09271481845943874, 0.15862503073718132,
									 0.23836105234771826, 0.3145816733484658, 0.3646378041738644,
									 0.3712083839028062, 0.3318955172714563, 0.2606239351263752,
									 0.17974645853927257, 0.10887932309109451, 0.057926522838099404,
									 0.027068644081232107, 0.0111102701871645, 0.004005585159914763,
									 0.0021937749042738597, 0.0067033981832786875, 0.01800027389742253,
									 0.042474520135566185, 0.08807027177068807, 0.16046117953300057,
									 0.25688621109211557, 0.36135513722062695, 0.4466268556327423,
									 0.4850306695003607, 0.46281349492451884, 0.3880217084493252,
									 0.2858393746315642, 0.18501587693787727, 0.10522618632029582,
									 0.052586661103082785, 0.02309273777608965, 0.0089112067871313,
									 0.0030218589308578254, 0.004939178581849699, 0.014098662469886513,
									 0.03538029061292948, 0.07805311612025555, 0.15137412100386152,
									 0.2580683987322659, 0.38675076765959676, 0.5094882313187259,
									 0.5899827081482911, 0.600543111688814, 0.5373392814192756,
									 0.4226241237495035, 0.2921898703374708, 0.1775771910438979,
									 0.09486989646997945, 0.04455526662187157, 0.018395487227793245,
									 0.006676971512937845, 0.003400205357687651, 0.010312386154327299,
									 0.027508763377476687, 0.06453937519303372, 0.13316995679439342,
									 0.24165941044303466, 0.38566245522292575, 0.5412645227742183,
									 0.6680435416762174, 0.7250860402384723, 0.6920899535957828,
									 0.5809309764054218, 0.4288233002777587, 0.2783742311027415,
									 0.1589218343381303, 0.07979049595354723, 0.035232470601617306,
									 0.013682730210653051, 0.0046736444562754205, 0.007044022455900266,
									 0.01996420037549371, 0.04978790994346554, 0.1092500190369781,
									 0.21092681324971413, 0.35829753767902356, 0.5354869099403373,
									 0.7041095863574072, 0.8145420251124132, 0.8290222160386312,
									 0.7423316624518148, 0.584804583744635, 0.40532972928879063,
									 0.24717077190760808, 0.1326126365646838, 0.06260112576849622,
									 0.026001669657207706, 0.009502912683741201, 0.004493229988569311,
									 0.013523730134841074, 0.03583246980451846, 0.08357628827771627,
									 0.17159369962425527, 0.31011265799218657, 0.493318792024074,
									 0.6907455317185286, 0.8513049310884097, 0.9234754740464557,
									 0.8817335718751622, 0.7410063912409892, 0.548128013660663,
									 0.35688027366312514, 0.20452704922013878, 0.10317534405308046,
									 0.04581519070242669, 0.0179087406813281, 0.006162519335265467,
									 0.008550575694341275, 0.02405859907077737, 0.05961759851985222,
									 0.130104537916925, 0.25004089878061825, 0.42317428516315586,
									 0.6306787819521847, 0.8276966054396023, 0.9565409057369303,
									 0.9734259059414612, 0.8723061573347386, 0.6883407966535073,
									 0.47831126558690323, 0.2926822442822168, 0.15771358252467232,
									 0.0748409356194105, 0.03127658300901751, 0.011511293290892802,
									 0.005045880650116091, 0.015069177426603457, 0.03965309006053008,
									 0.09193543030121278, 0.18779880310157107, 0.33798277779000296,
									 0.5358930767265444, 0.7485756401522188, 0.9212160767722073,
									 0.9987391311228152, 0.9539068928852112, 0.8026460141707795,
									 0.5949893689151138, 0.38856756403594317, 0.22356475114758426,
									 0.1133258505789697, 0.05061218710010909, 0.019915693862760108,
									 0.006905035735015363, 0.008804749108108958, 0.024590634479844307,
									 0.06054079723146744, 0.13138223453959458, 0.25131701986446475,
									 0.42373343272301023, 0.629709344756742, 0.8248164276333386,
									 0.9522249972123913, 0.9689123570972804, 0.8689439285543423,
									 0.6868520942323841, 0.47852316058748956, 0.2938442396194897,
									 0.1590428979950929, 0.0758760712678585, 0.03190814848300294,
									 0.011828223691234208, 0.004798802406882424, 0.014217691577438555,
									 0.037150184067867596, 0.08560748974859919, 0.1739670188072565,
									 0.3117554822431402, 0.49265528398582137, 0.686508785486614,
									 0.8435623586949872, 0.9140139896818394, 0.8732762654212229,
									 0.7357231577331683, 0.5465679111461372, 0.35805186307390074,
									 0.20683651132418895, 0.10536526827930431, 0.04733348705695256,
									 0.018752285763043677, 0.00655195274350321, 0.007663532865150922,
									 0.021241814265044873, 0.05194989512703549, 0.1120966104718632,
									 0.21340347711203958, 0.3584267260808227, 0.5311045828860669,
									 0.6942782713539, 0.8006749721252105, 0.8146022114054201,
									 0.7311412128668601, 0.5789288490890898, 0.40440960813818383,
									 0.2492277445940273, 0.13550598109245862, 0.06500075659999083,
									 0.027509908869530128, 0.010272728787823565, 0.0038507093151666366,
									 0.011316377669222614, 0.0293574953404218, 0.0672292820983102,
									 0.1358973909636735, 0.24247358309380812, 0.38186347867399345,
									 0.5308039423034402, 0.651233348016661, 0.7051994621514194,
									 0.6739982205196895, 0.5685619172093763, 0.42332317164164496,
									 0.27819339034050855, 0.16136506473586518, 0.08261707986836225,
									 0.037337021819148254, 0.014894747163315016, 0.005245254639655968,
									 0.0056165920467893815, 0.015448109055365047, 0.03752508510246269,
									 0.08050002390864855, 0.15250517871444588, 0.255138481260323,
									 0.37693017169912446, 0.49173645195086685, 0.5664814632491473,
									 0.5762597228486487, 0.5176423321114382, 0.41060306130864827,
									 0.2876071057123765, 0.17789693027842196, 0.09717114631154897,
									 0.04687238781274661, 0.019967366980017817, 0.007512142577361926,
									 0.002596864412490066, 0.00756852155582707, 0.01949106789502496,
									 0.04435124770427641, 0.08916753392502332, 0.15838925299504067,
									 0.24857204980451356, 0.34465004574975766, 0.4221802694871339,
									 0.4568855227583076, 0.43682280428213255, 0.3689711950307622,
									 0.275341664750816, 0.1815302543674192, 0.10573804001570292,
									 0.05441622962331873, 0.02474301592498054, 0.009940726314809169,
									 0.003528917061921654, 0.003452074977900986, 0.009419989039276485,
									 0.02272410442338048, 0.04845886164870205, 0.09134732094362305,
									 0.15220993023397605, 0.22418439449478716, 0.29186089050343744,
									 0.33585339045872503, 0.34160507278951247, 0.3071137888227843,
									 0.24404881161993996, 0.17141967191337196, 0.10642843252053676,
									 0.058408552022977636, 0.028335310022251276, 0.0121513772789499,
									 0.004606643162959672, 0.0014656603510190104, 0.004235575574998146,
									 0.010826330189133893, 0.02447498571503989, 0.048935143520652015,
									 0.08652940250678129, 0.13531327960390568, 0.18712971086312574,
									 0.22885725902198933, 0.2475155781406035, 0.2367308379599558,
									 0.20022689288953047, 0.1497643169147103, 0.09906449442928916,
									 0.05795075258659718, 0.0299806762224285, 0.013717572153734196,
									 0.005551125466937562, 0.001986870478011962, 0.0017715948078275581,
									 0.004795433561174588, 0.011486533654591489, 0.024346211203032268,
									 0.04566053736506924, 0.07577154381666353, 0.111254420827685,
									 0.14453308418340388, 0.1661312106289815, 0.1689532526152558,
									 0.15202427373531835, 0.1210298071378828, 0.08525287321335777,
									 0.053133635226587095, 0.029301016567152567, 0.014297484045929579,
									 0.006173248271555316, 0.002358635170175649, 0.0006891994612513363,
									 0.001974517857346614, 0.005008447908172585, 0.011247438118524161,
									 0.022361304305565776, 0.039356887181953466, 0.06132164157663778,
									 0.08458003432325531, 0.1032706549466716, 0.11161876956160036,
									 0.10679410726747643, 0.09044986878558728, 0.06781446144151469,
									 0.04500863571079376, 0.02644455537202001, 0.013754778921830406,
									 0.00633373992264732, 0.0025820863194885553, 0.0009319705113058686,
									 0.0007556330985554067, 0.002028574109867934, 0.004824022088162174,
									 0.010161308995710308, 0.018958229366530025, 0.03132865423720442,
									 0.045853446297429254, 0.05944033431493385, 0.06824401646314694,
									 0.06939359048434986, 0.06249499887648474, 0.04984760426955562,
									 0.03521443652761884, 0.022033386104290984, 0.012210536088778597,
									 0.0059936649058662155, 0.0026059615483479026, 0.0010036383949813034,
									 0.0002687219824507196, 0.0007630858744303605, 0.0019205048690675928,
									 0.004283624343031127, 0.008467317425765881, 0.01483220333603286,
									 0.023023962516690158, 0.031670912190946504, 0.03860477644354714,
									 0.0416982346828807, 0.03991066567535142, 0.03384977540439312,
									 0.025440245514376916, 0.016943026411619273, 0.009999371067155628,
									 0.005229697210203407, 0.0024239019941928474, 0.000995641623376265,
									 0.00036245798860451217, 0.0002665429206440118, 0.0007095516271141606,
									 0.0016749042574295242, 0.0035056485453522634, 0.006505861005253319,
									 0.010705012331738123, 0.015617296704079226, 0.020200099339558023,
									 0.02316461582086195, 0.023551468403375634, 0.02122911294113651,
									 0.016965579248851833, 0.012020786439209112, 0.007551463274573495,
									 0.004206030651314263, 0.002077151746083985, 0.000909561828376039,
									 0.0003531673321680714, 8.643374354499416e-05, 0.00024323261552258306,
									 0.0006072783855036825, 0.001345127176648156, 0.002643216467088325,
									 0.0046076840571536385, 0.007125286118140008, 0.009774240363465348,
									 0.011893744480244132, 0.012838232089848254, 0.012292532640729596,
									 0.01044065870841084, 0.007866254920800925, 0.005257354727122259,
									 0.0031169770779902383, 0.0016393710904843493, 0.0007649109987525659,
									 0.0003166281376623144, 0.00011628145035545788, 7.734461183213302e-05,
									 0.00020412753394946872, 0.0004782147745873858, 0.0009944371453225235,
									 0.0018354818175733579, 0.0030069697822882524, 0.0043722448133346765,
									 0.005642465096839946, 0.006462748191678066, 0.006569719687772977,
									 0.005927306302158652, 0.004746252819236664, 0.003373119598581352,
									 0.002127682207996827, 0.0011912010835352193, 0.0005919407133356566,
									 0.00026109589914582635, 0.00010222729520995774, 2.2808889992407194e-05,
									 6.359486305176738e-05, 0.00015748292756640112, 0.0003463540406506635,
									 0.0006764980477103027, 0.0011734346617409913, 0.0018075333013383309,
									 0.002472521466436561, 0.0030034051752498704, 0.003239693853356973,
									 0.0031031923432089602, 0.0026395443076095114, 0.001993737596713596,
									 0.0013373080051706228, 0.0007965761492540741, 0.00042137226982015075,
									 0.0001979521301269811, 8.25895594651594e-05, 3.0604016242729086e-05,
									 1.835835036464297e-05, 4.8025800930431286e-05, 0.00011164432720809,
									 0.00023062302819579453, 0.0004233094211363789, 0.0006903830892749954,
									 0.0010004361923372825, 0.00128809582448942, 0.0014735380761250938,
									 0.0014977048722538645, 0.0013525162248812467, 0.0010852059073333232,
									 0.0007736413895754053, 0.0004900405026842618, 0.00027580252532416304,
									 0.00013792726619688117, 6.129170397643457e-05, 2.4203010776532222e-05,
									 3.3296215442791036e-05, 7.269793860708401e-05, 0.00014111888715784507,
									 0.00024354007223651095, 0.0003736515521909734, 0.0005096422997671623,
									 0.0006179596394063201, 0.0006661112724770167, 0.0006382986841928229,
									 0.000543741499955773, 0.00041177090466013624, 0.0002772165543590775,
									 0.0001659170771969369, 8.828398798229291e-05, 4.176424571279596e-05,
									 1.7566066431390625e-05])

	return gaussian_beam




###
def make_Uniform_beam(image_size_pix, beam_peak_amplitude = 1.0):
	""" Make a square uniform kernel.
	"""
	uniform_beam = beam_peak_amplitude * np.ones([image_size_pix, image_size_pix])
	return uniform_beam




###
def Produce_Full_Coordinate_Arrays(nu, nv, nx, ny):
	#U_oversampling_Factor=nu/float(nx) #Keeps uv-plane size constant and oversampled rather than DFTing to a larger uv-plane
	#V_oversampling_Factor=nv/float(ny) #Keeps uv-plane size constant and oversampled rather than DFTing to a larger uv-plane
	#
	# i_y_Vector=(np.arange(ny)-ny/2)
	# #i_y_Vector=numpy.fft.fftshift(arange(ny)) #This puts the centre of x,y grid: 0,0 at the centre of the vector rather than the start
	# i_y_Vector=i_y_Vector.reshape(1,ny)
	# i_y_Array=np.tile(i_y_Vector,ny)
	# i_y_Array_Vectorised=i_y_Array.reshape(nx*ny,1)
	# i_y_AV=i_y_Array_Vectorised
	# #
	# i_x_Vector=(np.arange(nx)-nx/2)
	# #i_x_Vector=numpy.fft.fftshift(arange(nx)) #This puts the centre of x,y grid: 0,0 at the centre of the vector rather than the start
	# i_x_Vector=i_x_Vector.reshape(nx,1)
	# i_x_Array=np.tile(i_x_Vector,nx)
	# i_x_Array_Vectorised=i_x_Array.reshape(nx*ny,1)
	# i_x_AV=i_x_Array_Vectorised

	# Overwrite gridded xy coords with ones obtained from healvis.observatory.calc_azza
	coord_dir = '/users/jburba/data/jburba/bayes/BayesEoR/Linalg/hpx_coords/nside{}/'.format(p.nside)
	filename = 'fov-{:.1f}deg_pix-units.npy'.format(12.9)
	i_x_AV, i_y_AV = np.load(os.path.join(coord_dir, filename))
	i_x_AV = i_x_AV.reshape(-1, 1)
	i_y_AV = i_y_AV.reshape(-1, 1)

	#
	i_v_Vector=(np.arange(nu)-nu/2)
	#i_v_Vector= numpy.fft.fftshift(arange(nu)) #This puts the centre of u,v grid: 0,0 at the centre of the vector rather than the start
	i_v_Vector=i_v_Vector.reshape(1,nu)
	i_v_Array=np.tile(i_v_Vector,nv)
	i_v_Array_Vectorised=i_v_Array.reshape(1,nu*nv)
	i_v_AV=i_v_Array_Vectorised
	#
	i_u_Vector=(np.arange(nv)-nv/2)
	#i_u_Vector=numpy.fft.fftshift(arange(nv)) #This puts the centre of u,v grid: 0,0 at the centre of the vector rather than the start
	i_u_Vector=i_u_Vector.reshape(nv,1)
	i_u_Array=np.tile(i_u_Vector,nu)
	i_u_Array_Vectorised=i_u_Array.reshape(1,nv*nu)
	i_u_AV=i_u_Array_Vectorised
	#
	#
	#ExponentArray=np.exp(-2.0*np.pi*1j*( (i_x_AV*i_u_AV/float(nx)) +  (i_v_AV*i_y_AV/float(ny)) ))
	return i_x_AV, i_y_AV, i_u_AV, i_v_AV




###
def Produce_Coordinate_Arrays_ZM(nu, nv, nx, ny, **kwargs):
	##===== Defaults =======
	default_exclude_mean = True

	##===== Inputs =======
	exclude_mean=kwargs.pop('exclude_mean',default_exclude_mean)
	#
	# i_y_Vector=(np.arange(ny)-ny/2)
	# #i_y_Vector=numpy.fft.fftshift(arange(ny)) #This puts the centre of x,y grid: 0,0 at the centre of the vector rather than the start
	# i_y_Vector=i_y_Vector.reshape(1,ny)
	# i_y_Array=np.tile(i_y_Vector,ny)
	# i_y_Array_Vectorised=i_y_Array.reshape(nx*ny,1)
	# i_y_AV=i_y_Array_Vectorised
	# #
	# i_x_Vector=(np.arange(nx)-nx/2)
	# #i_x_Vector=numpy.fft.fftshift(arange(nx)) #This puts the centre of x,y grid: 0,0 at the centre of the vector rather than the start
	# i_x_Vector=i_x_Vector.reshape(nx,1)
	# i_x_Array=np.tile(i_x_Vector,nx)
	# i_x_Array_Vectorised=i_x_Array.reshape(nx*ny,1)
	# i_x_AV=i_x_Array_Vectorised

	# Overwrite gridded xy coords with ones obtained from healvis.observatory.calc_azza
	coord_dir = '/users/jburba/data/jburba/bayes/BayesEoR/Linalg/hpx_coords/nside{}/'.format(p.nside)
	filename = 'fov-{:.1f}deg_pix-units.npy'.format(12.9)
	i_x_AV, i_y_AV = np.load(os.path.join(coord_dir, filename))
	i_x_AV = i_x_AV.reshape(-1, 1)
	i_y_AV = i_y_AV.reshape(-1, 1)

	#
	i_v_Vector=(np.arange(nu)-nu/2)
	#i_v_Vector= numpy.fft.fftshift(arange(nu)) #This puts the centre of u,v grid: 0,0 at the centre of the vector rather than the start
	i_v_Vector=i_v_Vector.reshape(1,nu)
	i_v_Array=np.tile(i_v_Vector,nv)
	i_v_Array_Vectorised=i_v_Array.reshape(1,nu*nv)
	i_v_AV=i_v_Array_Vectorised
	if exclude_mean:
		i_v_AV=numpy.delete(i_v_AV,[i_v_AV.size/2]) #Remove the centre uv-pix
	#
	i_u_Vector=(np.arange(nv)-nv/2)
	#i_u_Vector=numpy.fft.fftshift(arange(nv)) #This puts the centre of u,v grid: 0,0 at the centre of the vector rather than the start
	i_u_Vector=i_u_Vector.reshape(nv,1)
	i_u_Array=np.tile(i_u_Vector,nu)
	i_u_Array_Vectorised=i_u_Array.reshape(1,nv*nu)
	i_u_AV=i_u_Array_Vectorised
	if exclude_mean:
		i_u_AV=numpy.delete(i_u_AV,[i_u_AV.size/2]) #Remove the centre uv-pix
	#
	#
	#ExponentArray=np.exp(-2.0*np.pi*1j*( (i_x_AV*i_u_AV/float(nx)) +  (i_v_AV*i_y_AV/float(ny)) ))
	return i_x_AV, i_y_AV, i_u_AV, i_v_AV




###
def Produce_Coordinate_Arrays_ZM_Coarse(nu, nv, nx, ny):
	#U_oversampling_Factor=nu/float(nx) #Keeps uv-plane size constant and oversampled rather than DFTing to a larger uv-plane
	#V_oversampling_Factor=nv/float(ny) #Keeps uv-plane size constant and oversampled rather than DFTing to a larger uv-plane
	#
	i_y_Vector=(np.arange(ny)-ny/2)
	#i_y_Vector=numpy.fft.fftshift(arange(ny)) #This puts the centre of x,y grid: 0,0 at the centre of the vector rather than the start
	i_y_Vector=i_y_Vector.reshape(1,ny)
	i_y_Array=np.tile(i_y_Vector,ny)
	i_y_Array_Vectorised=i_y_Array.reshape(nx*ny,1)
	i_y_AV=i_y_Array_Vectorised
	#
	i_x_Vector=(np.arange(nx)-nx/2)
	#i_x_Vector=numpy.fft.fftshift(arange(nx)) #This puts the centre of x,y grid: 0,0 at the centre of the vector rather than the start
	i_x_Vector=i_x_Vector.reshape(nx,1)
	i_x_Array=np.tile(i_x_Vector,nx)
	i_x_Array_Vectorised=i_x_Array.reshape(nx*ny,1)
	i_x_AV=i_x_Array_Vectorised
	#
	i_v_Vector=(np.arange(nu)-nu/2)
	#i_v_Vector= numpy.fft.fftshift(arange(nu)) #This puts the centre of u,v grid: 0,0 at the centre of the vector rather than the start
	i_v_Vector=i_v_Vector.reshape(1,nu)
	i_v_Array=np.tile(i_v_Vector,nv)
	i_v_Array_Vectorised=i_v_Array.reshape(1,nu*nv)
	i_v_AV=i_v_Array_Vectorised
	#
	GridSize=i_v_AV.size
	GridIndex, MaskOuterPoints=Calc_Indices_Centre_3x3_Grid(GridSize)
	InnerSubgridIndices=GridIndex[MaskOuterPoints]
	#
	Centre_v_CoordIndex=i_v_AV.size/2
	i_v_AV=numpy.delete(i_v_AV,InnerSubgridIndices) #Remove the centre 3x3 uv-grid (to be replaced by subharmonic grid)
	#i_v_AV=numpy.delete(i_v_AV,range(Centre_v_CoordIndex-4, Centre_v_CoordIndex+5,1)) #Remove the centre 3x3 uv-grid (to be replaced by subharmonic grid)
	#
	i_u_Vector=(np.arange(nv)-nv/2)
	#i_u_Vector=numpy.fft.fftshift(arange(nv)) #This puts the centre of u,v grid: 0,0 at the centre of the vector rather than the start
	i_u_Vector=i_u_Vector.reshape(nv,1)
	i_u_Array=np.tile(i_u_Vector,nu)
	i_u_Array_Vectorised=i_u_Array.reshape(1,nv*nu)
	i_u_AV=i_u_Array_Vectorised
	Centre_u_CoordIndex=i_u_AV.size/2
	i_u_AV=numpy.delete(i_u_AV,InnerSubgridIndices) #Remove the centre 3x3 uv-grid (to be replaced by subharmonic grid)
	#i_u_AV=numpy.delete(i_u_AV,range(Centre_u_CoordIndex-4, Centre_u_CoordIndex+5,1)) #Remove the centre 3x3 uv-grid (to be replaced by subharmonic grid)
	#
	#
	#ExponentArray=np.exp(-2.0*np.pi*1j*( (i_x_AV*i_u_AV/float(nx)) +  (i_v_AV*i_y_AV/float(ny)) ))
	return i_x_AV, i_y_AV, i_u_AV, i_v_AV








###
def Produce_Coordinate_Arrays_ZM_SH(nu, nv, nx, ny):
	#U_oversampling_Factor=nu/float(nx) #Keeps uv-plane size constant and oversampled rather than DFTing to a larger uv-plane
	#V_oversampling_Factor=nv/float(ny) #Keeps uv-plane size constant and oversampled rather than DFTing to a larger uv-plane
	#
	i_y_Vector=(np.arange(ny)-ny/2)
	#i_y_Vector=numpy.fft.fftshift(arange(ny)) #This puts the centre of x,y grid: 0,0 at the centre of the vector rather than the start
	i_y_Vector=i_y_Vector.reshape(1,ny)
	i_y_Array=np.tile(i_y_Vector,ny)
	i_y_Array_Vectorised=i_y_Array.reshape(nx*ny,1)
	i_y_AV=i_y_Array_Vectorised
	#
	i_x_Vector=(np.arange(nx)-nx/2)
	#i_x_Vector=numpy.fft.fftshift(arange(nx)) #This puts the centre of x,y grid: 0,0 at the centre of the vector rather than the start
	i_x_Vector=i_x_Vector.reshape(nx,1)
	i_x_Array=np.tile(i_x_Vector,nx)
	i_x_Array_Vectorised=i_x_Array.reshape(nx*ny,1)
	i_x_AV=i_x_Array_Vectorised
	#
	i_v_Vector=(np.arange(nu)-nu/2)
	#i_v_Vector= numpy.fft.fftshift(arange(nu)) #This puts the centre of u,v grid: 0,0 at the centre of the vector rather than the start
	i_v_Vector=i_v_Vector.reshape(1,nu)
	i_v_Array=np.tile(i_v_Vector,nv)
	i_v_Array_Vectorised=i_v_Array.reshape(1,nu*nv)
	i_v_AV=i_v_Array_Vectorised
	Centre_v_CoordIndex=i_v_AV.size/2
	i_v_AV=numpy.delete(i_v_AV,[Centre_v_CoordIndex]) #Remove the centre uv-pix
	#
	i_u_Vector=(np.arange(nv)-nv/2)
	#i_u_Vector=numpy.fft.fftshift(arange(nv)) #This puts the centre of u,v grid: 0,0 at the centre of the vector rather than the start
	i_u_Vector=i_u_Vector.reshape(nv,1)
	i_u_Array=np.tile(i_u_Vector,nu)
	i_u_Array_Vectorised=i_u_Array.reshape(1,nv*nu)
	i_u_AV=i_u_Array_Vectorised
	Centre_u_CoordIndex=i_u_AV.size/2
	i_u_AV=numpy.delete(i_u_AV,[Centre_u_CoordIndex]) #Remove the centre uv-pix
	#
	#
	#ExponentArray=np.exp(-2.0*np.pi*1j*( (i_x_AV*i_u_AV/float(nx)) +  (i_v_AV*i_y_AV/float(ny)) ))
	return i_x_AV, i_y_AV, i_u_AV, i_v_AV





###
def Calc_Coords_High_Res_Im_to_Large_uv(i_x_AV, i_y_AV, i_u_AV, i_v_AV, X_oversampling_Factor=1.0, Y_oversampling_Factor=1.0):
	#
	Y_oversampling_Factor=float(Y_oversampling_Factor)
	X_oversampling_Factor=float(X_oversampling_Factor)
	#
	i_y_AV=i_y_AV/Y_oversampling_Factor #Keeps xy-plane size constant and oversampled rather than DFTing from a larger xy-plane
	i_x_AV=i_x_AV/X_oversampling_Factor #Keeps xy-plane size constant and oversampled rather than DFTing from a larger xy-plane
	#
	return i_x_AV, i_y_AV, i_u_AV, i_v_AV




###
def Calc_Coords_Large_Im_to_High_Res_uv(i_x_AV, i_y_AV, i_u_AV, i_v_AV, U_oversampling_Factor=1.0, V_oversampling_Factor=1.0):
	#
	V_oversampling_Factor=float(V_oversampling_Factor)
	U_oversampling_Factor=float(U_oversampling_Factor)
	#
	i_v_AV=i_v_AV/V_oversampling_Factor #Keeps uv-plane size constant and oversampled rather than DFTing to a larger uv-plane
	i_u_AV=i_u_AV/U_oversampling_Factor #Keeps uv-plane size constant and oversampled rather than DFTing to a larger uv-plane
	#
	return i_x_AV, i_y_AV, i_u_AV, i_v_AV







def Restore_Centre_Pixel(Array, MeanVal=0.0):
	#
	Restored_Array=numpy.insert(Array, [Array.size/2],[MeanVal])

	return Restored_Array





def Calc_Indices_Centre_3x3_Grid(GridSize):
	#
	GridLength=int(GridSize**0.5)
	#
	LenX=LenY=GridLength
	#
	GridIndex=arange(LenX*LenY).reshape(LenX,LenY)
	Mask=zeros(LenX*LenY).reshape(LenX,LenY)
	Mask[len(Mask)/2-1:len(Mask)/2+2,len(Mask[0])/2-1:len(Mask[0])/2+2]=1
	#
	MaskOuterPoints=Mask.astype('bool')
	#
	return GridIndex, MaskOuterPoints



def Delete_Centre_3x3_Grid(Array):
	#
	GridSize=Array.size
	GridIndex, MaskOuterPoints=Calc_Indices_Centre_3x3_Grid(GridSize)
	#
	OuterArray=np.delete(Array, GridIndex[MaskOuterPoints])
	#
	return OuterArray




def Delete_Centre_Pix(Array):
	#
	Array=numpy.delete(Array, [Array.size/2])

	return Array



def N_is_Odd(N):
	return N%2


def Calc_Indices_Centre_NxN_Grid(GridSize, N):
	#
	GridLength=int(GridSize**0.5)
	#
	LenX=LenY=GridLength
	#
	GridIndex=arange(LenX*LenY).reshape(LenX,LenY)
	Mask=zeros(LenX*LenY).reshape(LenX,LenY)
	if N_is_Odd(N):
		Mask[len(Mask)/2-(N/2):len(Mask)/2+(N/2+1),len(Mask[0])/2-(N/2):len(Mask[0])/2+(N/2+1)]=1
	else:
		Mask[len(Mask)/2-(N/2):len(Mask)/2+(N/2),len(Mask[0])/2-(N/2):len(Mask[0])/2+(N/2)]=1
	#
	MaskOuterPoints=Mask.astype('bool')
	#
	return GridIndex, MaskOuterPoints


def Obtain_Centre_NxN_Grid(Array, N):
	#
	GridSize=Array.size
	GridIndex, MaskOuterPoints=Calc_Indices_Centre_NxN_Grid(GridSize, N)
	#
	Centre_NxN_Grid=Array.flatten()[GridIndex[MaskOuterPoints]]
	#
	return Centre_NxN_Grid



def Restore_Centre_3x3_Grid(Array, MeanVal=0.0):
	#
	LenRestoredArray=Array.size+9
	#
	GridSize=LenRestoredArray
	GridIndex, MaskOuterPoints=Calc_Indices_Centre_3x3_Grid(GridSize)
	#
	CurrentPointsIndex=GridIndex[np.where(np.logical_not(MaskOuterPoints))]
	RestoredPointsIndex=GridIndex[np.where((MaskOuterPoints))]
	#
	ConcatIndices=np.concatenate((CurrentPointsIndex,RestoredPointsIndex))
	SortedIndices=ConcatIndices.argsort()
	#
	Restored_Array_Unsorted=numpy.append(Array,[MeanVal]*9)
	Restored_Array=Restored_Array_Unsorted[SortedIndices]
	#
	return Restored_Array



def Restore_Centre_NxN_Grid(Array1, Array2, N):
	#
	LenRestoredArray=Array1.size+N*N
	#
	GridSize=LenRestoredArray
	GridIndex, MaskOuterPoints=Calc_Indices_Centre_NxN_Grid(GridSize, N)
	#
	CurrentPointsIndex=GridIndex[np.where(np.logical_not(MaskOuterPoints))]
	RestoredPointsIndex=GridIndex[np.where((MaskOuterPoints))]
	#
	ConcatIndices=np.concatenate((CurrentPointsIndex,RestoredPointsIndex))
	SortedIndices=ConcatIndices.argsort()
	#
	Restored_Array_Unsorted=numpy.append(Array1,Array2)
	Restored_Array=Restored_Array_Unsorted[SortedIndices]
	#
	return Restored_Array



def Generate_Combined_Coarse_plus_Subharmic_uv_grids(nu, nv, nx, ny, X_oversampling_Factor, Y_oversampling_Factor, U_oversampling_Factor, V_oversampling_Factor, ReturnSeparateCoarseandSHarrays=False):
	#U_oversampling_Factor and V_oversampling_Factor are the factors by which the subharmonic grid is oversampled relative to the coarse grid.
	#
	nu_SH=3*int(U_oversampling_Factor)
	nv_SH=3*int(V_oversampling_Factor)
	n_SH=(nu_SH*nv_SH)-1
	#
	i_x_AV_C, i_y_AV_C, i_u_AV_C, i_v_AV_C = Produce_Coordinate_Arrays_ZM_Coarse(nu, nv, nx, ny)
	i_x_AV_SH, i_y_AV_SH, i_u_AV_SH, i_v_AV_SH = Produce_Coordinate_Arrays_ZM_SH(nu_SH, nv_SH, nx, ny)
	#
	if U_oversampling_Factor!=1.0:
		i_x_AV_SH, i_y_AV_SH, i_u_AV_SH, i_v_AV_SH = Calc_Coords_Large_Im_to_High_Res_uv(i_x_AV_SH, i_y_AV_SH, i_u_AV_SH, i_v_AV_SH, U_oversampling_Factor, V_oversampling_Factor)
	if X_oversampling_Factor!=1.0:
		i_x_AV_C, i_y_AV_C, i_u_AV_C, i_v_AV_C = Calc_Coords_High_Res_Im_to_Large_uv(i_x_AV_C, i_y_AV_C, i_u_AV_C, i_v_AV_C, X_oversampling_Factor, Y_oversampling_Factor)
	#
	#Combine Coarse and subharmic uv-grids.
	i_u_AV=np.concatenate((i_u_AV_C, i_u_AV_SH))
	i_v_AV=np.concatenate((i_v_AV_C, i_v_AV_SH))
	#
	i_x_AV=i_x_AV_C
	i_y_AV=i_y_AV_C
	#
	if not ReturnSeparateCoarseandSHarrays:
		return i_u_AV, i_v_AV, i_x_AV, i_y_AV
	else:
		return i_u_AV_C, i_u_AV_SH, i_v_AV_C, i_v_AV_SH, i_x_AV, i_y_AV



def IDFT_Array_IDFT_2D_ZM_SH(nu, nv, nx, ny, X_oversampling_Factor=1.0, Y_oversampling_Factor=1.0, U_oversampling_Factor=1.0, V_oversampling_Factor=1.0):
	#U_oversampling_Factor and V_oversampling_Factor are the factors by which the subharmonic grid is oversampled relative to the coarse grid.
	#
	i_u_AV, i_v_AV, i_x_AV, i_y_AV = Generate_Combined_Coarse_plus_Subharmic_uv_grids(nu, nv, nx, ny, X_oversampling_Factor, Y_oversampling_Factor, U_oversampling_Factor, V_oversampling_Factor)
	#
	ExponentArray=np.exp(+2.0*np.pi*1j*( (i_x_AV*i_u_AV/float(nu)) +  (i_v_AV*i_y_AV/float(nv)) ))
	#
	NormalisedExponentArray=ExponentArray.T
	NormalisedExponentArray=NormalisedExponentArray/((nu*nv))

	return NormalisedExponentArray





#######
#Generates a DFT matrix (DFTArray) where upon dot producting with the input image (TestData) yields FFTTestData_Hermitian:
#FFTTestData_Hermitian = np.dot(TestData.reshape(1,nx*ny), DFTArrayF2).reshape(nu,nv)
#(= np.dot(DFTArrayF2.T,TestData.reshape(1,nx*ny).T).reshape(nu,nv))

#And is equivalent in numpy to:

#ShiftedTestData    = numpy.fft.ifftshift(TestData+0j, axes=(0,1))
#FFTTestData        = numpy.fft.fftn(ShiftedTestData, axes=(0,1))
#ShiftedFFTTestData = numpy.fft.fftshift(FFTTestData, axes=(0,1))
#######

###
def DFT_Array_DFT_2D(nu, nv, nx, ny, X_oversampling_Factor=1.0, Y_oversampling_Factor=1.0, U_oversampling_Factor=1.0, V_oversampling_Factor=1.0):
	#
	i_x_AV, i_y_AV, i_u_AV, i_v_AV = Produce_Full_Coordinate_Arrays(nu, nv, nx, ny)
	#
	if U_oversampling_Factor!=1.0:
		i_x_AV, i_y_AV, i_u_AV, i_v_AV = Calc_Coords_Large_Im_to_High_Res_uv(i_x_AV, i_y_AV, i_u_AV, i_v_AV, U_oversampling_Factor, V_oversampling_Factor)
	if X_oversampling_Factor!=1.0:
		i_x_AV, i_y_AV, i_u_AV, i_v_AV = Calc_Coords_High_Res_Im_to_Large_uv(i_x_AV, i_y_AV, i_u_AV, i_v_AV, U_oversampling_Factor, V_oversampling_Factor)
	#
	ExponentArray=np.exp(-2.0*np.pi*1j*( (i_x_AV*i_u_AV/float(nx)) +  (i_v_AV*i_y_AV/float(ny)) ))
	return ExponentArray





###
# non-uniform DFT from image space to uv-coordinates given by p.uvw_multi_time_step_array_meters_reshaped (for examples, the sub-100m baselines sampled by HERA 331).
###
def nuDFT_Array_DFT_2D(nu, nv, nx, ny, chan_freq_MHz, sampled_uvw_coords_m, X_oversampling_Factor=1.0, Y_oversampling_Factor=1.0, U_oversampling_Factor=1.0, V_oversampling_Factor=1.0):
	#
	# sampled_uvw_coords_m = p.uvw_multi_time_step_array_meters_reshaped
	sampled_uvw_coords_wavelengths = sampled_uvw_coords_m/(p.speed_of_light/(chan_freq_MHz*1.e6)) # Convert uv-coordinates from meters to wavelengths at frequency chan_freq_MHz
	sampled_uvw_coords_inverse_pixel_units = sampled_uvw_coords_wavelengths/p.uv_pixel_width_wavelengths #Convert uv-coordinates from wavelengths to inverse pixel units

	i_x_AV, i_y_AV, i_u_AV, i_v_AV = Produce_Full_Coordinate_Arrays(nu, nv, nx, ny)
	# Overwrite gridded uv coords with instrumental uv coords loaded in params
	i_u_AV = sampled_uvw_coords_inverse_pixel_units[:,0].reshape(1,-1)
	i_v_AV = sampled_uvw_coords_inverse_pixel_units[:,1].reshape(1,-1)
	#
	if U_oversampling_Factor!=1.0:
		i_x_AV, i_y_AV, i_u_AV, i_v_AV = Calc_Coords_Large_Im_to_High_Res_uv(i_x_AV, i_y_AV, i_u_AV, i_v_AV, U_oversampling_Factor, V_oversampling_Factor)
	if X_oversampling_Factor!=1.0:
		i_x_AV, i_y_AV, i_u_AV, i_v_AV = Calc_Coords_High_Res_Im_to_Large_uv(i_x_AV, i_y_AV, i_u_AV, i_v_AV, U_oversampling_Factor, V_oversampling_Factor)
	#
	ExponentArray=np.exp(+2.0*np.pi*1j*( (i_x_AV*i_u_AV/float(nx)) +  (i_v_AV*i_y_AV/float(ny)) ))
	return ExponentArray




###
# non-uniform DFT from image space to uv-coordinates given by sampled_uvw_coords_inverse_pixel_units (for examples, the sub-100m baselines sampled by HERA 331).
###
def nuDFT_Array_DFT_2D_v2d0(nu, nv, nx, ny, sampled_uvw_coords_inverse_pixel_units, X_oversampling_Factor=1.0, Y_oversampling_Factor=1.0, U_oversampling_Factor=1.0, V_oversampling_Factor=1.0):

	i_x_AV, i_y_AV, i_u_AV, i_v_AV = Produce_Full_Coordinate_Arrays(nu, nv, nx, ny)
	# Overwrite gridded uv coords with instrumental uv coords loaded in params
	i_u_AV = sampled_uvw_coords_inverse_pixel_units[:,0].reshape(1,-1)
	i_v_AV = sampled_uvw_coords_inverse_pixel_units[:,1].reshape(1,-1)
	#
	if U_oversampling_Factor!=1.0:
		i_x_AV, i_y_AV, i_u_AV, i_v_AV = Calc_Coords_Large_Im_to_High_Res_uv(i_x_AV, i_y_AV, i_u_AV, i_v_AV, U_oversampling_Factor, V_oversampling_Factor)
	if X_oversampling_Factor!=1.0:
		i_x_AV, i_y_AV, i_u_AV, i_v_AV = Calc_Coords_High_Res_Im_to_Large_uv(i_x_AV, i_y_AV, i_u_AV, i_v_AV, U_oversampling_Factor, V_oversampling_Factor)
	#
	###
	# Converting from pixel units to dimensionful units
	###
	# For now, using healpix coordinates, i_x_AV and i_y_AV come out in units
	# of pixel units, so they need to be scaled by the sqrt of the pixel area
	i_x_AV *= np.sqrt(p.sky_model_pixel_area_sr)
	i_y_AV *= np.sqrt(p.sky_model_pixel_area_sr)
	# The uv coordinates also need to be scaled back into units of wavelengths
	# by multiplying by the uv pixel area
	i_u_AV = i_u_AV.astype('float') * p.uv_pixel_width_wavelengths
	i_v_AV = i_v_AV.astype('float') * p.uv_pixel_width_wavelengths
	# This formulation expects (l, m) and (u, v) in radians and wavelengths, respectively
	ExponentArray=np.exp(+2.0*np.pi*1j*( (i_x_AV*i_u_AV) +  (i_v_AV*i_y_AV) ))
	# I think this array should use the - sign in the argument of the exponent
	# because Fprime and Fz both use the + sign

	# This formulation expects (l, m) and (u, v) in pixel units
	# ExponentArray=np.exp(+2.0*np.pi*1j*( (i_x_AV*i_u_AV/float(nx)) +  (i_v_AV*i_y_AV/float(ny)) ))
	return ExponentArray


# a = np.ones([9,9])
# nuidft = nuDFT_Array_DFT_2D(nu, nv, nx, ny, 159.0)
# b3 = np.dot(nudft.T, a.reshape(-1,1))
# md_nudft =  block_diag(*[nuDFT_Array_DFT_2D(nu, nv, nx, ny, chan_freq_MHz) for chan_freq_MHz in np.linspace(159.,168.,p.nf)])






#######
#Generates a IDFT matrix (IDFTArray) where upon dot producting with the input image (TestData) yields FFTTestData_Hermitian:
#FFTTestData_Hermitian = np.dot(TestData.reshape(1,nx*ny), DFTArrayF2).reshape(nu,nv)
#(= np.dot(DFTArrayF2.T,TestData.reshape(1,nx*ny).T).reshape(nu,nv))

#And is equivalent in numpy to:

#ShiftedTestData    = numpy.fft.ifftshift(TestData+0j, axes=(0,1))
#FFTTestData        = numpy.fft.fftn(ShiftedTestData, axes=(0,1))
#ShiftedFFTTestData = numpy.fft.fftshift(FFTTestData, axes=(0,1))
#######

###
def IDFT_Array_IDFT_2D(nu, nv, nx, ny, X_oversampling_Factor=1.0, Y_oversampling_Factor=1.0, U_oversampling_Factor=1.0, V_oversampling_Factor=1.0):
	#
	i_x_AV, i_y_AV, i_u_AV, i_v_AV = Produce_Full_Coordinate_Arrays(nu, nv, nx, ny)
	#
	if U_oversampling_Factor!=1.0:
		i_x_AV, i_y_AV, i_u_AV, i_v_AV = Calc_Coords_Large_Im_to_High_Res_uv(i_x_AV, i_y_AV, i_u_AV, i_v_AV, U_oversampling_Factor, V_oversampling_Factor)
	if X_oversampling_Factor!=1.0:
		i_x_AV, i_y_AV, i_u_AV, i_v_AV = Calc_Coords_High_Res_Im_to_Large_uv(i_x_AV, i_y_AV, i_u_AV, i_v_AV, U_oversampling_Factor, V_oversampling_Factor)
	#
	ExponentArray=np.exp(+2.0*np.pi*1j*( (i_x_AV*i_u_AV/float(nu)) +  (i_v_AV*i_y_AV/float(nv)) ))
	#return ExponentArray.T/(nu*U_oversampling_Factor*nv*V_oversampling_Factor)
	return ExponentArray.T/(nu*U_oversampling_Factor*nv*V_oversampling_Factor)






###
def DFT_Array_DFT_2D_ZM(nu, nv, nx, ny, X_oversampling_Factor=1.0, Y_oversampling_Factor=1.0, U_oversampling_Factor=1.0, V_oversampling_Factor=1.0):
	#
	exclude_mean = True
	if p.fit_for_monopole:
		exclude_mean = False
	i_x_AV, i_y_AV, i_u_AV, i_v_AV = Produce_Coordinate_Arrays_ZM(nu, nv, nx, ny, exclude_mean = exclude_mean)
	#
	if U_oversampling_Factor!=1.0:
		i_x_AV, i_y_AV, i_u_AV, i_v_AV = Calc_Coords_Large_Im_to_High_Res_uv(i_x_AV, i_y_AV, i_u_AV, i_v_AV, U_oversampling_Factor, V_oversampling_Factor)
	if X_oversampling_Factor!=1.0:
		i_x_AV, i_y_AV, i_u_AV, i_v_AV = Calc_Coords_High_Res_Im_to_Large_uv(i_x_AV, i_y_AV, i_u_AV, i_v_AV, U_oversampling_Factor, V_oversampling_Factor)
	#
	ExponentArray=np.exp(-2.0*np.pi*1j*( (i_x_AV*i_u_AV/float(nx)) +  (i_v_AV*i_y_AV/float(ny)) ))
	return ExponentArray





###
def IDFT_Array_IDFT_2D_ZM(nu, nv, nx, ny, X_oversampling_Factor=1.0, Y_oversampling_Factor=1.0, U_oversampling_Factor=1.0, V_oversampling_Factor=1.0):
	#
	exclude_mean = True
	if p.fit_for_monopole:
		exclude_mean = False
	i_x_AV, i_y_AV, i_u_AV, i_v_AV = Produce_Coordinate_Arrays_ZM(nu, nv, nx, ny, exclude_mean = exclude_mean)

	#
	if U_oversampling_Factor!=1.0:
		i_x_AV, i_y_AV, i_u_AV, i_v_AV = Calc_Coords_Large_Im_to_High_Res_uv(i_x_AV, i_y_AV, i_u_AV, i_v_AV, U_oversampling_Factor, V_oversampling_Factor)
	if X_oversampling_Factor!=1.0:
		i_x_AV, i_y_AV, i_u_AV, i_v_AV = Calc_Coords_High_Res_Im_to_Large_uv(i_x_AV, i_y_AV, i_u_AV, i_v_AV, U_oversampling_Factor, V_oversampling_Factor)
	#
	###
	# Converting from pixel units to dimensionful units
	###
	# For now, using healpix coordinates, i_x_AV and i_y_AV come out in units
	# of pixel units, so they need to be scaled by the sqrt of the pixel area
	i_x_AV *= np.sqrt(p.sky_model_pixel_area_sr)
	i_y_AV *= np.sqrt(p.sky_model_pixel_area_sr)
	# The uv coordinates also need to be scaled back into units of wavelengths
	# by multiplying by the uv pixel area
	i_u_AV = i_u_AV.astype('float') * p.uv_pixel_width_wavelengths
	i_v_AV = i_v_AV.astype('float') * p.uv_pixel_width_wavelengths
	# This formulation expects (l, m) and (u, v) in radians and wavelengths, respectively
	# ExponentArray=np.exp(+2.0*np.pi*1j*( (i_x_AV*i_u_AV) +  (i_v_AV*i_y_AV) ))
	# Sign change for consistency, Finv chosen to have + to match healvis
	ExponentArray=np.exp(-2.0*np.pi*1j*( (i_x_AV*i_u_AV) +  (i_v_AV*i_y_AV) ))

	# This formulation expects (l, m) and (u, v) in pixel units
	# ExponentArray=np.exp(+2.0*np.pi*1j*( (i_x_AV*i_u_AV/float(nu)) +  (i_v_AV*i_y_AV/float(nv)) ))
	#return ExponentArray.T/(nu*U_oversampling_Factor*nv*V_oversampling_Factor)
	return ExponentArray.T/(nu*U_oversampling_Factor*nv*V_oversampling_Factor)






#####


def Construct_Hermitian(Tri_Real, Tri_Imag):
	Nx=int(((len(Tri_Real)*2)-1)**0.5)
	#
	Full_Real=np.concatenate((Tri_Real,Tri_Real[:-1][::-1])).reshape(Nx,Nx)
	Full_Imag=np.concatenate((Tri_Imag,-1.0*Tri_Imag[:-1][::-1])).reshape(Nx,Nx)
	#
	return Full_Real+1j*Full_Imag




###
#1. Construct G
###
#Assumes parameters are ordered: all real then all imaginary and the parameters are the upper triangular values of the uv-plane (which describes the whole uv-plane since it is Hermitian so UV[i,j]=UV[-i,-j] (or UV[-1-i,-1-j] in python because of zero indexing).
def Construct_Hermitian_Gridding_Matrix(nu,nv):
	#n_par=((nu*(nv-1)/2))*2
	n_par=((nu*nv/2)+1)*2
	#n_par=((nu*nv/2))*2 #Not including the offset term
	n_par_div2=n_par/2
	#
	G=np.zeros([nu*nv,n_par])+0j
	#
	###
	#Real Part
	###
	G[:n_par/2,:nu*nv/2+1] = np.identity(n_par/2) #Fill the first half of the matrix -- Upper tri (transposed) including the centre -- with the  real param values
	G[n_par/2:,:nu*nv/2+1] = np.identity(n_par/2)[:-1][::-1] #Fill the second half of the matrix -- Lower tri (transposed) minus the centre -- with the  real param values in reverse order (reverse order done by the [::-1])
	###
	#Imag Part
	###
	G[:n_par/2,nu*nv/2+1:] = +1j*np.identity(n_par/2) #Fill the first half of the matrix -- Upper tri (transposed) including the centre -- with the  imag param values
	G[n_par/2:,nu*nv/2+1:] = -1j*np.identity(n_par/2)[:-1][::-1] #Fill the second half of the matrix -- Lower tri (transposed) minus the centre -- with the  imag param values in reverse order (reverse order done by the [::-1])
	return G





###
#1. Construct G
###
#Assumes parameters are ordered: all real then all imaginary and the parameters are the upper triangular values of the uv-plane (which describes the whole uv-plane since it is Hermitian so UV[i,j]=UV[-i,-j] (or UV[-1-i,-1-j] in python because of zero indexing).
def Construct_Hermitian_Gridding_Matrix_CosSin(nu,nv):
	#n_par=((nu*nv/2)+1)*2
	n_par=((nu*nv/2))*2 #Not including the offset term
	n_par_div2=n_par/2
	#
	G=np.zeros([nu*nv*2,n_par])
	#
	###
	#Real Part
	###
	G[:nu*nv/2,:n_par/2] = np.identity(n_par/2) #Fill the first half of the matrix -- Upper tri (transposed) including the centre -- with the  real param values
	G[nu*nv/2+1:nu*nv,:n_par/2] = np.identity(n_par/2)[::-1] #Fill the second half of the matrix -- Lower tri (transposed) minus the centre -- with the  real param values in reverse order (reverse order done by the [::-1])
	###
	#Imag Part
	###
	G[nu*nv:3*nu*nv/2,n_par/2:] = np.identity(n_par/2) #Fill the first half of the matrix -- Upper tri (transposed) including the centre -- with the  imag param values
	G[3*nu*nv/2+1:nu*nv*2,n_par/2:] = -1*np.identity(n_par/2)[::-1] #Fill the second half of the matrix -- Lower tri (transposed) minus the centre -- with the  imag param values in reverse order (reverse order done by the [::-1])
	return G








###
#1. Construct G
###
#Assumes parameters are ordered: Coarse Grid - all real then all imaginary and the parameters are the upper triangular values of the uv-plane (which describes the whole uv-plane since it is Hermitian so UV[i,j]=UV[-i,-j] (or UV[-1-i,-1-j] in python because of zero indexing) minus the lines corresponding to the 9 central pixels. Followed by Subharmonic Grid  - all real then all imaginary and the parameters are the upper triangular values of the oversampled centre 9 coords of the uv-plane.
def Construct_Hermitian_Gridding_Matrix_CosSin_SH_v4(nu,nv, U_oversampling_Factor, V_oversampling_Factor):
	n_par=(nu*nv-9) #Complete coarse grid
	#
	nu_SH=3*U_oversampling_Factor
	nv_SH=3*V_oversampling_Factor
	n_par_SH=(nu_SH*nv_SH-1) #Zero mean (ie. missing centre pix) subharmonic grid
	#
	G=np.zeros([n_par*2+n_par_SH*2,n_par+n_par_SH])
	#
	###
	#Real Part Coarse grid
	###
	G[:n_par/2,:n_par/2] = np.identity(n_par/2) #Fill the first half of the matrix -- Upper tri (transposed) including the centre -- with the  real param values
	G[n_par/2:n_par,:n_par/2] = np.identity(n_par/2)[::-1] #Fill the second half of the matrix -- Lower tri (transposed) minus the centre -- with the  real param values in reverse order (reverse order done by the [::-1])
	###
	#Real Part Subharmonic grid
	###
	G[n_par:n_par+n_par_SH/2, n_par/2:n_par/2+n_par_SH/2] = np.identity(n_par_SH/2) #Fill the first half of the matrix -- Upper tri (transposed) including the centre -- with the  real param values
	G[n_par+n_par_SH/2:n_par+n_par_SH, n_par/2:n_par/2+n_par_SH/2] = np.identity(n_par_SH/2)[::-1] #Fill the second half of the matrix -- Lower tri (transposed) minus the centre -- with the  real param values in reverse order (reverse order done by the [::-1])
	###
	#
	###
	#Imag Part Coarse grid
	###
	G[n_par+n_par_SH:3*n_par/2+n_par_SH,n_par/2+n_par_SH/2:n_par+n_par_SH/2] = np.identity(n_par/2) #Fill the first half of the matrix -- Upper tri (transposed) including the centre -- with the  imag param values
	G[3*n_par/2+n_par_SH:n_par*2+n_par_SH,n_par/2+n_par_SH/2:n_par+n_par_SH/2] = -1*np.identity(n_par/2)[::-1] #Fill the second half of the matrix -- Lower tri (transposed) minus the centre -- with the  imag param values in reverse order (reverse order done by the [::-1])
	#Imag Part Subharmonic grid
	###
	G[n_par*2+n_par_SH:n_par*2+3*n_par_SH/2, n_par+n_par_SH/2:n_par+n_par_SH] = np.identity(n_par_SH/2) #Fill the first half of the matrix -- Upper tri (transposed) including the centre -- with the  imag param values
	G[n_par*2+3*n_par_SH/2:n_par*2+n_par_SH*2,n_par+n_par_SH/2:n_par+n_par_SH] = -1*np.identity(n_par_SH/2)[::-1] #Fill the second half of the matrix -- Lower tri (transposed) minus the centre -- with the  imag param values in reverse order (reverse order done by the [::-1])

	return G







###
def IDFT_Array_IDFT_1D(nf, neta):
	i_f=(np.arange(nf)-nf/2).reshape(-1,1)
	i_eta=(np.arange(neta)-neta/2).reshape(1,-1)
	# ExponentArray=np.exp(+2.0*np.pi*1j*( (i_eta*i_f/float(nf)) ))
	# Sign change for consistency, Finv chosen to have + signa to match healvis
	ExponentArray=np.exp(-2.0*np.pi*1j*( (i_eta*i_f/float(nf)) ))
	return ExponentArray/float(nf)




# ###
# def quadratic_array_linear_plus_quad_modes_only_v2(neta, nq=2):
# 	quadratic_array = np.zeros([nq,neta])+0j
# 	# quadratic_array[0] = arange(neta)
# 	# quadratic_array[1] = arange(neta)**2.0
# 	# quadratic_array[2] = 1j*arange(neta)
# 	# quadratic_array[3] = 1j*arange(neta)**2
# 	quadratic_array[0] = arange(neta)+1j*arange(neta)
# 	quadratic_array[1] = arange(neta)**2.0+1j*arange(neta)**2
# 	return quadratic_array




###
def quadratic_array_linear_plus_quad_modes_only_v2(nf, nq=2, **kwargs):
	##===== Defaults =======
	default_npl = 0
	default_nu_min_MHz = (163.0-4.0)
	default_channel_width_MHz = 0.2
	default_beta = 2.63

	##===== Inputs =======
	npl=kwargs.pop('npl',default_npl)
	nu_min_MHz=kwargs.pop('nu_min_MHz',default_nu_min_MHz)
	channel_width_MHz=kwargs.pop('channel_width_MHz',default_channel_width_MHz)
	beta=kwargs.pop('beta',default_beta)

	quadratic_array = np.zeros([nq,nf])+0j
	if nq==1:
		x=arange(nf)-(nf/2.)
		quadratic_array[0] = x
		if npl==1:
			###
			# This function needs modifying so that the following information is passed to it rather than being hard coded!
			###
			# nu_min_MHz = (163.0-4.0)
			# channel_width_MHz = 0.2
			# # beta_experimental_mean = 2.63+0
			# beta = 2.63
			###
			nu_array_MHz = nu_min_MHz+np.arange(float(nf))*channel_width_MHz
			m_pl = np.array([(nu_array_MHz[i_nu]/nu_min_MHz)**-beta for i_nu in range(len(nu_array_MHz))])
			quadratic_array[0] = m_pl
			print '\nLinear LW mode replaced with power-law model'
			print 'nu_min_MHz = ', nu_min_MHz
			print 'channel_width_MHz = ', channel_width_MHz
			print 'beta = ', beta, '\n'
	if nq==2:
		x=arange(nf)-(nf/2.)
		quadratic_array[0] = x
		quadratic_array[1] = x**2
		#
		if npl==1:
			###
			# This function needs modifying so that the following information is passed to it rather than being hard coded!
			###
			# nu_min_MHz = (163.0-4.0)
			# channel_width_MHz = 0.2
			# # beta_experimental_mean = 2.63+0
			# beta = 2.63
			###
			nu_array_MHz = nu_min_MHz+np.arange(float(nf))*channel_width_MHz
			m_pl = np.array([(nu_array_MHz[i_nu]/nu_min_MHz)**-beta for i_nu in range(len(nu_array_MHz))])
			quadratic_array[1] = m_pl
			print '\nQuadratic LW mode replaced with power-law model'
			print 'nu_min_MHz = ', nu_min_MHz
			print 'channel_width_MHz = ', channel_width_MHz
			print 'beta = ', beta, '\n'
		if npl==2:
			###
			# This function needs modifying so that the following information is passed to it rather than being hard coded!
			###
			# nu_min_MHz = (163.0-4.0)
			# channel_width_MHz = 0.2
			# # beta_experimental_mean = 2.63+0
			# beta = 2.63
			###
			nu_array_MHz = nu_min_MHz+np.arange(float(nf))*channel_width_MHz
			m_pl1 = np.array([(nu_array_MHz[i_nu]/nu_min_MHz)**-beta[0] for i_nu in range(len(nu_array_MHz))])
			quadratic_array[0] = m_pl1
			print '\nLinear LW mode replaced with power-law model'
			print 'beta1 = ', beta[0], '\n'
			m_pl2 = np.array([(nu_array_MHz[i_nu]/nu_min_MHz)**-beta[1] for i_nu in range(len(nu_array_MHz))])
			quadratic_array[1] = m_pl2
			print '\nQuadratic LW mode replaced with power-law model'
			print 'nu_min_MHz = ', nu_min_MHz
			print 'channel_width_MHz = ', channel_width_MHz
			print 'beta2 = ', beta[1], '\n'
		#
	if nq==3:
		x=arange(nf)-(nf/2.)
		quadratic_array[0] = x
		quadratic_array[1] = x**2
		quadratic_array[1] = x**3
		#
		if npl==1:
			###
			# This function needs modifying so that the following information is passed to it rather than being hard coded!
			###
			# nu_min_MHz = (163.0-4.0)
			# channel_width_MHz = 0.2
			# # beta_experimental_mean = 2.63+0
			# beta = 2.63
			###
			nu_array_MHz = nu_min_MHz+np.arange(float(nf))*channel_width_MHz
			m_pl = np.array([(nu_array_MHz[i_nu]/nu_min_MHz)**-beta for i_nu in range(len(nu_array_MHz))])
			quadratic_array[1] = m_pl
			print '\nQuadratic LW mode replaced with power-law model'
			print 'nu_min_MHz = ', nu_min_MHz
			print 'channel_width_MHz = ', channel_width_MHz
			print 'beta = ', beta, '\n'
		if npl==2:
			nu_array_MHz = nu_min_MHz+np.arange(float(nf))*channel_width_MHz
			m_pl1 = np.array([(nu_array_MHz[i_nu]/nu_min_MHz)**-beta[0] for i_nu in range(len(nu_array_MHz))])
			quadratic_array[0] = m_pl1
			print '\nLinear LW mode replaced with power-law model'
			print 'beta1 = ', beta[0], '\n'
			m_pl2 = np.array([(nu_array_MHz[i_nu]/nu_min_MHz)**-beta[1] for i_nu in range(len(nu_array_MHz))])
			quadratic_array[1] = m_pl2
			print '\nQuadratic LW mode replaced with power-law model'
			print 'nu_min_MHz = ', nu_min_MHz
			print 'channel_width_MHz = ', channel_width_MHz
			print 'beta2 = ', beta[1], '\n'
		if npl==3:
			nu_array_MHz = nu_min_MHz+np.arange(float(nf))*channel_width_MHz
			m_pl1 = np.array([(nu_array_MHz[i_nu]/nu_min_MHz)**-beta[0] for i_nu in range(len(nu_array_MHz))])
			quadratic_array[0] = m_pl1
			print '\nLinear LW mode replaced with power-law model'
			print 'beta1 = ', beta[0], '\n'
			m_pl2 = np.array([(nu_array_MHz[i_nu]/nu_min_MHz)**-beta[1] for i_nu in range(len(nu_array_MHz))])
			quadratic_array[1] = m_pl2
			print '\nQuadratic LW mode replaced with power-law model'
			print 'beta2 = ', beta[1], '\n'
			m_pl3 = np.array([(nu_array_MHz[i_nu]/nu_min_MHz)**-beta[1] for i_nu in range(len(nu_array_MHz))])
			quadratic_array[2] = m_pl3
			print '\nCubic LW mode replaced with power-law model'
			print 'nu_min_MHz = ', nu_min_MHz
			print 'channel_width_MHz = ', channel_width_MHz
			print 'beta3 = ', beta[2], '\n'
		#
	if nq==4:
		quadratic_array[0] = arange(nf)
		quadratic_array[1] = arange(nf)**2.0
		quadratic_array[2] = 1j*arange(nf)
		quadratic_array[3] = 1j*arange(nf)**2
	return quadratic_array




###
def quadratic_array_linear_plus_quad_modes_only_v2_ZM(nf, nq=2):
	quadratic_array = np.zeros([nq,nf-1])+0j
	if nq==2:
		# x=arange(nf)-(nf/2)
		# quadratic_array[0] = x+0j*x
		# quadratic_array[1] = x**2.0+0j*x**2
		# x=arange(nf)+0.0
		x=arange(nf-1)-0.
		# x=arange(nf)-(nf/2)
		quadratic_array[0] = x
		quadratic_array[1] = x**2
		# quadratic_array[0] = x+1j*x
		# quadratic_array[1] = 1j*x**2
		# quadratic_array[1] = x**2.0+1j*x**2
	if nq==3:
		x=arange(nf-1)
		# x=arange(nf)-(nf/2)
		quadratic_array[0] = np.ones(len(x))
		quadratic_array[1] = x+1j*x
		quadratic_array[2] = x**2.0+1j*x**2
	if nq==4:
		quadratic_array[0] = arange(nf-1)
		quadratic_array[1] = arange(nf-1)**2.0
		quadratic_array[2] = 1j*arange(nf-1)
		quadratic_array[3] = 1j*arange(nf-1)**2
	return quadratic_array




###
def IDFT_Array_IDFT_1D_WQ(nf, neta, nq, **kwargs):
	##===== Defaults =======
	default_npl = 0
	default_nu_min_MHz = (163.0-4.0)
	default_channel_width_MHz = 0.2
	default_beta = 2.63

	##===== Inputs =======
	npl=kwargs.pop('npl',default_npl)
	nu_min_MHz=kwargs.pop('nu_min_MHz',default_nu_min_MHz)
	channel_width_MHz=kwargs.pop('channel_width_MHz',default_channel_width_MHz)
	beta=kwargs.pop('beta',default_beta)

	i_f=(np.arange(nf)-nf/2).reshape(-1,1)
	i_eta=(np.arange(neta)-neta/2).reshape(1,-1)
	# ExponentArray=np.exp(+2.0*np.pi*1j*( (i_eta*i_f/float(nf)) ))
	# Sign change for consistency, Finv chosen to have + sign to match healvis
	ExponentArray=np.exp(-2.0*np.pi*1j*( (i_eta*i_f/float(nf)) ))
	ExponentArray = ExponentArray/float(nf)
	quadratic_array = quadratic_array_linear_plus_quad_modes_only_v2(nf, nq, npl=npl, nu_min_MHz=nu_min_MHz, channel_width_MHz=channel_width_MHz, beta=beta)
	print quadratic_array
	# quadratic_array = quadratic_array_linear_plus_quad_modes_only(neta)
	Exponent_plus_quadratic_array = np.hstack((ExponentArray,quadratic_array.T))
	return Exponent_plus_quadratic_array.T




###
def IDFT_Array_IDFT_1D_WQ_ZM(nf, neta, nq):
	i_f=(np.arange(nf)-nf/2)
	i_eta=(np.arange(neta)-neta/2)

	# i_f=np.delete(i_f,np.where(i_f==0))
	i_eta=np.delete(i_eta,np.where(i_eta==0))

	i_f=i_f.reshape(-1,1)
	i_eta=i_eta.reshape(1,-1)

	ExponentArray=np.exp(+2.0*np.pi*1j*( (i_eta*i_f/float(nf)) ))
	ExponentArray = ExponentArray/float(nf)
	quadratic_array = quadratic_array_linear_plus_quad_modes_only_v2_ZM(neta, nq)
	print quadratic_array
	# quadratic_array = quadratic_array_linear_plus_quad_modes_only(neta)
	Exponent_plus_quadratic_array = np.vstack((ExponentArray,quadratic_array))
	return Exponent_plus_quadratic_array.T




###
def IDFT_Array_IDFT_1D_ZM(nf, neta):
	i_eta=(np.arange(neta)-neta/2).reshape(1,-1)
	i_f=(np.arange(nf)-nf/2)
	i_f=i_f[i_f!=0].reshape(-1,1) #Remove the centre uv-pix
	ExponentArray=np.exp(+2.0*np.pi*1j*( (i_eta*i_f/float(nf)) ))
	return ExponentArray/float(nf)





#------------------------------------------
#------Construct gridding matrix-----------
#------------------------------------------
###
# Note: the gridding logic works as follows:
# - In visibility order there are 37 complex numbers per vis (in the ZM case) follwing the 1D DFT (eta -> frequency)
# - Following gridding there will be (nu*nv-1) coarse grid points per channel
# - If d1 is the data in channel order with the numbers:
# [[0, 1, 2],
#  [3, 4, 5],
#  [6, 7, 8]]
# in d1[0], however, 4 is removed by the ZM; then the order of the first values in the visibility spectra in d1.T.flatten() will be: 0,3,6,1,7,2,5,8. So, the gridder needs to grab values in the order: 0*37+i_chan, 3*37+i_chan, 6*37+i_chan, 1*37+i_chan, etc. up to 8.

# could pre-build a list with e.g. 0,3,6,1,7,2,5,8 in it (generalised to the relevant nu and nv size) for selection from, rather than generating on the fly!?

def calc_vis_selection_numbers(nu,nv):
	required_chan_order = arange(nu*nv).reshape(nu,nv)
	visibility_spectrum_order = required_chan_order.T
	grab_order_for_visibility_spectrum_ordered_to_chan_ordered_reordering = visibility_spectrum_order.argsort()
	return grab_order_for_visibility_spectrum_ordered_to_chan_ordered_reordering

def calc_vis_selection_numbers_v2d0(nu,nv):
	required_chan_order = arange(nu*nv).reshape(nu,nv)
	visibility_spectrum_order = required_chan_order.T
	r = ((np.arange(nu)-nu/2).reshape(-1,1)**2. + (np.arange(nv)-nv/2).reshape(1,-1)**2.)**0.5
	non_excluded_values_mask = r>=0.0 #No values should be masked if the mean is included
	visibility_spectrum_order_ZM = visibility_spectrum_order[non_excluded_values_mask]
	grab_order_for_visibility_spectrum_ordered_to_chan_ordered_reordering_ZM = visibility_spectrum_order_ZM.argsort()
	return grab_order_for_visibility_spectrum_ordered_to_chan_ordered_reordering_ZM

def calc_vis_selection_numbers_ZM(nu,nv):
	required_chan_order = arange(nu*nv).reshape(nu,nv)
	visibility_spectrum_order = required_chan_order.T
	r = ((np.arange(nu)-nu/2).reshape(-1,1)**2. + (np.arange(nv)-nv/2).reshape(1,-1)**2.)**0.5
	non_excluded_values_mask = r>0.5 #true for everything other than the central pixel (note r==r.T)
	visibility_spectrum_order_ZM = visibility_spectrum_order[non_excluded_values_mask]
	grab_order_for_visibility_spectrum_ordered_to_chan_ordered_reordering_ZM = visibility_spectrum_order_ZM.argsort()
	return grab_order_for_visibility_spectrum_ordered_to_chan_ordered_reordering_ZM

def calc_vis_selection_numbers_SH(nu,nv, U_oversampling_Factor=1.0, V_oversampling_Factor=1.0):
	required_chan_order = arange(nu*nv).reshape(nu,nv)
	visibility_spectrum_order = required_chan_order.T
	r = ((np.arange(nu)-nu/2).reshape(-1,1)**2. + (np.arange(nv)-nv/2).reshape(1,-1)**2.)**0.5
	non_excluded_values_mask = r>1.5 #true for everything other than the central 9 pix
	visibility_spectrum_order_ZM_coarse_grid = visibility_spectrum_order[non_excluded_values_mask]
	grab_order_for_visibility_spectrum_ordered_to_chan_ordered_reordering_ZM_coarse_grid = visibility_spectrum_order_ZM_coarse_grid.argsort()
	grab_order_for_visibility_spectrum_ordered_to_chan_ordered_reordering_ZM_SH_grid = calc_vis_selection_numbers_ZM(3*U_oversampling_Factor, 3*V_oversampling_Factor)
	return grab_order_for_visibility_spectrum_ordered_to_chan_ordered_reordering_ZM_coarse_grid, grab_order_for_visibility_spectrum_ordered_to_chan_ordered_reordering_ZM_SH_grid



def generate_gridding_matrix_vis_ordered_to_chan_ordered(nu,nv,nf):
	if p.fit_for_monopole:
		vis_grab_order = calc_vis_selection_numbers_v2d0(nu,nv)
	else:
		vis_grab_order = calc_vis_selection_numbers_ZM(nu,nv)
	vals_per_chan = vis_grab_order.size

	gridding_matrix_vis_ordered_to_chan_ordered = np.zeros([vals_per_chan*(nf), vals_per_chan*(nf)])
	###
	for i in range(nf):
		for j, vis_grab_val in enumerate(vis_grab_order):
				row_number = (i*vals_per_chan)+j
				grid_pix = i+vis_grab_val*(nf) #pixel to grab from vis-ordered vector and place as next chan-ordered value
				# print i,j,vis_grab_val,row_number,grid_pix
				gridding_matrix_vis_ordered_to_chan_ordered[row_number, grid_pix]=1
	return gridding_matrix_vis_ordered_to_chan_ordered



def generate_gridding_matrix_vis_ordered_to_chan_ordered_ZM(nu,nv,nf):
	if p.fit_for_monopole:
		vis_grab_order = calc_vis_selection_numbers_v2d0(nu,nv)
	else:
		vis_grab_order = calc_vis_selection_numbers_ZM(nu,nv)
	vals_per_chan = vis_grab_order.size

	gridding_matrix_vis_ordered_to_chan_ordered = np.zeros([vals_per_chan*(nf-1), vals_per_chan*(nf-1)])
	###
	for i in range(nf-1):
		for j, vis_grab_val in enumerate(vis_grab_order):
				row_number = (i*vals_per_chan)+j
				grid_pix = i+vis_grab_val*(nf-1) #pixel to grab from vis-ordered vector and place as next chan-ordered value
				# print i,j,vis_grab_val,row_number,grid_pix
				gridding_matrix_vis_ordered_to_chan_ordered[row_number, grid_pix]=1
	return gridding_matrix_vis_ordered_to_chan_ordered



def generate_gridding_matrix_vis_ordered_to_chan_ordered_WQ(nu,nv,nf):
	"""
	Re-order matrix from vis-ordered to chan-ordered and place Fourier modes at the top and quadratic modes at the bottom.
	"""
	if p.fit_for_monopole:
		vis_grab_order = calc_vis_selection_numbers_v2d0(nu,nv)
	else:
		vis_grab_order = calc_vis_selection_numbers_ZM(nu,nv)
	vals_per_chan = vis_grab_order.size
	Fourier_vals_per_chan = vis_grab_order.size
	quadratic_vals_per_chan = 2

	gridding_matrix_vis_ordered_to_chan_ordered = np.zeros([vals_per_chan*(nf+2), vals_per_chan*(nf+2)])
	###
	for i in range(nf):
		for j, vis_grab_val in enumerate(vis_grab_order):
				row_number = (i*Fourier_vals_per_chan)+j
				grid_pix = i+vis_grab_val*(nf+2) #pixel to grab from vis-ordered vector and place as next chan-ordered value
				# print i,j,vis_grab_val,row_number,grid_pix
				gridding_matrix_vis_ordered_to_chan_ordered[row_number, grid_pix]=1
	# print 'Hello'
	for j, vis_grab_val in enumerate(vis_grab_order):
		for i in range(2):
				n_fourier_modes = (nf*Fourier_vals_per_chan) #Place quadratic modes after all of the Fourier modes in the resulting vector
				row_number = n_fourier_modes+(j*quadratic_vals_per_chan)+i #Place quadratic modes after all of the Fourier modes in the resulting vector
				grid_pix = nf+i+vis_grab_val*(nf+2) #pixel to grab from vis-ordered vector and place as next chan-ordered value
				# print i,j,vis_grab_val,row_number,grid_pix
				gridding_matrix_vis_ordered_to_chan_ordered[row_number, grid_pix]=1
	return gridding_matrix_vis_ordered_to_chan_ordered




# nu=3
# nv=3
# nf=6
# gridding_matrix_vis_ordered_to_chan_ordered_ZM = generate_gridding_matrix_vis_ordered_to_chan_ordered_ZM(nu,nv,nf)

# ###
# # Test 3D with 1D zero mean
# ###
# a=np.arange((nf-1)*nu*nv).reshape((nf-1),nu,nv)
# a1=a.T.flatten()
# remove_indices = [np.where(a1==x) for x in (((nu*nv)/2)+arange(nf-1)*(nu*nv))]
# a2=np.delete(a1, remove_indices)

# ga2 = np.dot(gridding_matrix_vis_ordered_to_chan_ordered_ZM, a2.reshape(-1,1))




# correct_order_zm = np.delete(arange(nf*nu*nv),[np.where(arange(nf*nu*nv)==x) for x in (((nu*nv)/2)+arange(nf)*(nu*nv))])
# print abs(ga2.flatten()-correct_order_zm).max() #If the printout is 0.0 then gridding_matrix_vis_ordered_to_chan_ordered is correctly constructed!






# nu=5
# nv=5
# nf=6
# gridding_matrix_vis_ordered_to_chan_ordered_WQ = generate_gridding_matrix_vis_ordered_to_chan_ordered_WQ(nu,nv,nf)

# ###
# # Test 3D with 1D zero mean
# ###
# a=np.arange(nf*nu*nv).reshape(nf,nu,nv)
# a1=a.T.flatten()
# remove_indices = [np.where(a1==x) for x in (((nu*nv)/2)+arange(nf)*(nu*nv))]
# a2=np.delete(a1, remove_indices)
# a2 = a2.reshape(-1,1)
# a3 = a2.reshape(-1,6)
# a4 = np.array([np.concatenate((x,(100+2*i,101+2*i))) for i, x in enumerate(a3)])

# ga2 = np.dot(gridding_matrix_vis_ordered_to_chan_ordered_WQ, a4.reshape(-1,1))




# # correct_order_zm = np.delete(arange(nf*nu*nv),[np.where(arange(nf*nu*nv)==x) for x in (((nu*nv)/2)+arange(nf)*(nu*nv))])
# # print abs(ga2.flatten()-correct_order_zm).max() #If the printout is 0.0 then gridding_matrix_vis_ordered_to_chan_ordered is correctly constructed!






